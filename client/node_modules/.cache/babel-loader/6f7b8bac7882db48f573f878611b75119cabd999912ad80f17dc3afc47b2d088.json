{"ast":null,"code":"/*\n  @license\n\tRollup.js v3.18.0\n\tWed, 01 Mar 2023 18:45:12 GMT - commit 25bdc129d21685b69a00ee55397d42ac6eff6449\n\n\thttps://github.com/rollup/rollup\n\n\tReleased under the MIT License.\n*/\nimport { resolve } from 'node:path';\nimport process$1 from 'node:process';\nimport { picomatchExports, getAugmentedNamespace, fseventsImporter, createFilter, rollupInternal } from './node-entry.js';\nimport { platform } from 'node:os';\nimport require$$0$1 from 'fs';\nimport require$$2 from 'util';\nimport require$$1 from 'stream';\nimport require$$0$2 from 'path';\nimport require$$2$1 from 'os';\nimport require$$0$3 from 'events';\nimport 'node:perf_hooks';\nimport 'node:crypto';\nimport 'node:fs/promises';\nimport 'node:events';\nimport 'tty';\nvar chokidar = {};\nconst fs$3 = require$$0$1;\nconst {\n  Readable\n} = require$$1;\nconst sysPath$3 = require$$0$2;\nconst {\n  promisify: promisify$3\n} = require$$2;\nconst picomatch$1 = picomatchExports;\nconst readdir$1 = promisify$3(fs$3.readdir);\nconst stat$3 = promisify$3(fs$3.stat);\nconst lstat$2 = promisify$3(fs$3.lstat);\nconst realpath$1 = promisify$3(fs$3.realpath);\n\n/**\n * @typedef {Object} EntryInfo\n * @property {String} path\n * @property {String} fullPath\n * @property {fs.Stats=} stats\n * @property {fs.Dirent=} dirent\n * @property {String} basename\n */\n\nconst BANG$2 = '!';\nconst RECURSIVE_ERROR_CODE = 'READDIRP_RECURSIVE_ERROR';\nconst NORMAL_FLOW_ERRORS = new Set(['ENOENT', 'EPERM', 'EACCES', 'ELOOP', RECURSIVE_ERROR_CODE]);\nconst FILE_TYPE = 'files';\nconst DIR_TYPE = 'directories';\nconst FILE_DIR_TYPE = 'files_directories';\nconst EVERYTHING_TYPE = 'all';\nconst ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];\nconst isNormalFlowError = error => NORMAL_FLOW_ERRORS.has(error.code);\nconst [maj, min] = process.versions.node.split('.').slice(0, 2).map(n => Number.parseInt(n, 10));\nconst wantBigintFsStats = process.platform === 'win32' && (maj > 10 || maj === 10 && min >= 5);\nconst normalizeFilter = filter => {\n  if (filter === undefined) return;\n  if (typeof filter === 'function') return filter;\n  if (typeof filter === 'string') {\n    const glob = picomatch$1(filter.trim());\n    return entry => glob(entry.basename);\n  }\n  if (Array.isArray(filter)) {\n    const positive = [];\n    const negative = [];\n    for (const item of filter) {\n      const trimmed = item.trim();\n      if (trimmed.charAt(0) === BANG$2) {\n        negative.push(picomatch$1(trimmed.slice(1)));\n      } else {\n        positive.push(picomatch$1(trimmed));\n      }\n    }\n    if (negative.length > 0) {\n      if (positive.length > 0) {\n        return entry => positive.some(f => f(entry.basename)) && !negative.some(f => f(entry.basename));\n      }\n      return entry => !negative.some(f => f(entry.basename));\n    }\n    return entry => positive.some(f => f(entry.basename));\n  }\n};\nclass ReaddirpStream extends Readable {\n  static get defaultOptions() {\n    return {\n      root: '.',\n      /* eslint-disable no-unused-vars */\n      fileFilter: path => true,\n      directoryFilter: path => true,\n      /* eslint-enable no-unused-vars */\n      type: FILE_TYPE,\n      lstat: false,\n      depth: 2147483648,\n      alwaysStat: false\n    };\n  }\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super({\n      objectMode: true,\n      autoDestroy: true,\n      highWaterMark: options.highWaterMark || 4096\n    });\n    const opts = {\n      ...ReaddirpStream.defaultOptions,\n      ...options\n    };\n    const {\n      root,\n      type\n    } = opts;\n    this._fileFilter = normalizeFilter(opts.fileFilter);\n    this._directoryFilter = normalizeFilter(opts.directoryFilter);\n    const statMethod = opts.lstat ? lstat$2 : stat$3;\n    // Use bigint stats if it's windows and stat() supports options (node 10+).\n    if (wantBigintFsStats) {\n      this._stat = path => statMethod(path, {\n        bigint: true\n      });\n    } else {\n      this._stat = statMethod;\n    }\n    this._maxDepth = opts.depth;\n    this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsEverything = type === EVERYTHING_TYPE;\n    this._root = sysPath$3.resolve(root);\n    this._isDirent = 'Dirent' in fs$3 && !opts.alwaysStat;\n    this._statsProp = this._isDirent ? 'dirent' : 'stats';\n    this._rdOptions = {\n      encoding: 'utf8',\n      withFileTypes: this._isDirent\n    };\n\n    // Launch stream with one parent, the root dir.\n    this.parents = [this._exploreDir(root, 1)];\n    this.reading = false;\n    this.parent = undefined;\n  }\n  async _read(batch) {\n    if (this.reading) return;\n    this.reading = true;\n    try {\n      while (!this.destroyed && batch > 0) {\n        const {\n          path,\n          depth,\n          files = []\n        } = this.parent || {};\n        if (files.length > 0) {\n          const slice = files.splice(0, batch).map(dirent => this._formatEntry(dirent, path));\n          for (const entry of await Promise.all(slice)) {\n            if (this.destroyed) return;\n            const entryType = await this._getEntryType(entry);\n            if (entryType === 'directory' && this._directoryFilter(entry)) {\n              if (depth <= this._maxDepth) {\n                this.parents.push(this._exploreDir(entry.fullPath, depth + 1));\n              }\n              if (this._wantsDir) {\n                this.push(entry);\n                batch--;\n              }\n            } else if ((entryType === 'file' || this._includeAsFile(entry)) && this._fileFilter(entry)) {\n              if (this._wantsFile) {\n                this.push(entry);\n                batch--;\n              }\n            }\n          }\n        } else {\n          const parent = this.parents.pop();\n          if (!parent) {\n            this.push(null);\n            break;\n          }\n          this.parent = await parent;\n          if (this.destroyed) return;\n        }\n      }\n    } catch (error) {\n      this.destroy(error);\n    } finally {\n      this.reading = false;\n    }\n  }\n  async _exploreDir(path, depth) {\n    let files;\n    try {\n      files = await readdir$1(path, this._rdOptions);\n    } catch (error) {\n      this._onError(error);\n    }\n    return {\n      files,\n      depth,\n      path\n    };\n  }\n  async _formatEntry(dirent, path) {\n    let entry;\n    try {\n      const basename = this._isDirent ? dirent.name : dirent;\n      const fullPath = sysPath$3.resolve(sysPath$3.join(path, basename));\n      entry = {\n        path: sysPath$3.relative(this._root, fullPath),\n        fullPath,\n        basename\n      };\n      entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);\n    } catch (err) {\n      this._onError(err);\n    }\n    return entry;\n  }\n  _onError(err) {\n    if (isNormalFlowError(err) && !this.destroyed) {\n      this.emit('warn', err);\n    } else {\n      this.destroy(err);\n    }\n  }\n  async _getEntryType(entry) {\n    // entry may be undefined, because a warning or an error were emitted\n    // and the statsProp is undefined\n    const stats = entry && entry[this._statsProp];\n    if (!stats) {\n      return;\n    }\n    if (stats.isFile()) {\n      return 'file';\n    }\n    if (stats.isDirectory()) {\n      return 'directory';\n    }\n    if (stats && stats.isSymbolicLink()) {\n      const full = entry.fullPath;\n      try {\n        const entryRealPath = await realpath$1(full);\n        const entryRealPathStats = await lstat$2(entryRealPath);\n        if (entryRealPathStats.isFile()) {\n          return 'file';\n        }\n        if (entryRealPathStats.isDirectory()) {\n          const len = entryRealPath.length;\n          if (full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath$3.sep) {\n            const recursiveError = new Error(`Circular symlink detected: \"${full}\" points to \"${entryRealPath}\"`);\n            recursiveError.code = RECURSIVE_ERROR_CODE;\n            return this._onError(recursiveError);\n          }\n          return 'directory';\n        }\n      } catch (error) {\n        this._onError(error);\n      }\n    }\n  }\n  _includeAsFile(entry) {\n    const stats = entry && entry[this._statsProp];\n    return stats && this._wantsEverything && !stats.isDirectory();\n  }\n}\n\n/**\n * @typedef {Object} ReaddirpArguments\n * @property {Function=} fileFilter\n * @property {Function=} directoryFilter\n * @property {String=} type\n * @property {Number=} depth\n * @property {String=} root\n * @property {Boolean=} lstat\n * @property {Boolean=} bigint\n */\n\n/**\n * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.\n * @param {String} root Root directory\n * @param {ReaddirpArguments=} options Options to specify root (start directory), filters and recursion depth\n */\nconst readdirp$1 = function (root) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let type = options.entryType || options.type;\n  if (type === 'both') type = FILE_DIR_TYPE; // backwards-compatibility\n  if (type) options.type = type;\n  if (!root) {\n    throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');\n  } else if (typeof root !== 'string') {\n    throw new TypeError('readdirp: root argument must be a string. Usage: readdirp(root, options)');\n  } else if (type && !ALL_TYPES.includes(type)) {\n    throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(', ')}`);\n  }\n  options.root = root;\n  return new ReaddirpStream(options);\n};\nconst readdirpPromise = function (root) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return new Promise((resolve, reject) => {\n    const files = [];\n    readdirp$1(root, options).on('data', entry => files.push(entry)).on('end', () => resolve(files)).on('error', error => reject(error));\n  });\n};\nreaddirp$1.promise = readdirpPromise;\nreaddirp$1.ReaddirpStream = ReaddirpStream;\nreaddirp$1.default = readdirp$1;\nvar readdirp_1 = readdirp$1;\nvar anymatchExports = {};\nvar anymatch$2 = {\n  get exports() {\n    return anymatchExports;\n  },\n  set exports(v) {\n    anymatchExports = v;\n  }\n};\n\n/*!\n * normalize-path <https://github.com/jonschlinkert/normalize-path>\n *\n * Copyright (c) 2014-2018, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nvar normalizePath$2 = function (path, stripTrailing) {\n  if (typeof path !== 'string') {\n    throw new TypeError('expected path to be a string');\n  }\n  if (path === '\\\\' || path === '/') return '/';\n  var len = path.length;\n  if (len <= 1) return path;\n\n  // ensure that win32 namespaces has two leading slashes, so that the path is\n  // handled properly by the win32 version of path.parse() after being normalized\n  // https://msdn.microsoft.com/library/windows/desktop/aa365247(v=vs.85).aspx#namespaces\n  var prefix = '';\n  if (len > 4 && path[3] === '\\\\') {\n    var ch = path[2];\n    if ((ch === '?' || ch === '.') && path.slice(0, 2) === '\\\\\\\\') {\n      path = path.slice(2);\n      prefix = '//';\n    }\n  }\n  var segs = path.split(/[/\\\\]+/);\n  if (stripTrailing !== false && segs[segs.length - 1] === '') {\n    segs.pop();\n  }\n  return prefix + segs.join('/');\n};\nObject.defineProperty(anymatchExports, \"__esModule\", {\n  value: true\n});\nconst picomatch = picomatchExports;\nconst normalizePath$1 = normalizePath$2;\n\n/**\n * @typedef {(testString: string) => boolean} AnymatchFn\n * @typedef {string|RegExp|AnymatchFn} AnymatchPattern\n * @typedef {AnymatchPattern|AnymatchPattern[]} AnymatchMatcher\n */\nconst BANG$1 = '!';\nconst DEFAULT_OPTIONS = {\n  returnIndex: false\n};\nconst arrify$1 = item => Array.isArray(item) ? item : [item];\n\n/**\n * @param {AnymatchPattern} matcher\n * @param {object} options\n * @returns {AnymatchFn}\n */\nconst createPattern = (matcher, options) => {\n  if (typeof matcher === 'function') {\n    return matcher;\n  }\n  if (typeof matcher === 'string') {\n    const glob = picomatch(matcher, options);\n    return string => matcher === string || glob(string);\n  }\n  if (matcher instanceof RegExp) {\n    return string => matcher.test(string);\n  }\n  return string => false;\n};\n\n/**\n * @param {Array<Function>} patterns\n * @param {Array<Function>} negPatterns\n * @param {String|Array} args\n * @param {Boolean} returnIndex\n * @returns {boolean|number}\n */\nconst matchPatterns = (patterns, negPatterns, args, returnIndex) => {\n  const isList = Array.isArray(args);\n  const _path = isList ? args[0] : args;\n  if (!isList && typeof _path !== 'string') {\n    throw new TypeError('anymatch: second argument must be a string: got ' + Object.prototype.toString.call(_path));\n  }\n  const path = normalizePath$1(_path, false);\n  for (let index = 0; index < negPatterns.length; index++) {\n    const nglob = negPatterns[index];\n    if (nglob(path)) {\n      return returnIndex ? -1 : false;\n    }\n  }\n  const applied = isList && [path].concat(args.slice(1));\n  for (let index = 0; index < patterns.length; index++) {\n    const pattern = patterns[index];\n    if (isList ? pattern(...applied) : pattern(path)) {\n      return returnIndex ? index : true;\n    }\n  }\n  return returnIndex ? -1 : false;\n};\n\n/**\n * @param {AnymatchMatcher} matchers\n * @param {Array|string} testString\n * @param {object} options\n * @returns {boolean|number|Function}\n */\nconst anymatch$1 = function (matchers, testString) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_OPTIONS;\n  if (matchers == null) {\n    throw new TypeError('anymatch: specify first argument');\n  }\n  const opts = typeof options === 'boolean' ? {\n    returnIndex: options\n  } : options;\n  const returnIndex = opts.returnIndex || false;\n\n  // Early cache for matchers.\n  const mtchers = arrify$1(matchers);\n  const negatedGlobs = mtchers.filter(item => typeof item === 'string' && item.charAt(0) === BANG$1).map(item => item.slice(1)).map(item => picomatch(item, opts));\n  const patterns = mtchers.filter(item => typeof item !== 'string' || typeof item === 'string' && item.charAt(0) !== BANG$1).map(matcher => createPattern(matcher, opts));\n  if (testString == null) {\n    return function (testString) {\n      let ri = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      const returnIndex = typeof ri === 'boolean' ? ri : false;\n      return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n    };\n  }\n  return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n};\nanymatch$1.default = anymatch$1;\nanymatch$2.exports = anymatch$1;\n\n/*!\n * is-extglob <https://github.com/jonschlinkert/is-extglob>\n *\n * Copyright (c) 2014-2016, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\nvar isExtglob$1 = function isExtglob(str) {\n  if (typeof str !== 'string' || str === '') {\n    return false;\n  }\n  var match;\n  while (match = /(\\\\).|([@?!+*]\\(.*\\))/g.exec(str)) {\n    if (match[2]) return true;\n    str = str.slice(match.index + match[0].length);\n  }\n  return false;\n};\n\n/*!\n * is-glob <https://github.com/jonschlinkert/is-glob>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nvar isExtglob = isExtglob$1;\nvar chars = {\n  '{': '}',\n  '(': ')',\n  '[': ']'\n};\nvar strictCheck = function (str) {\n  if (str[0] === '!') {\n    return true;\n  }\n  var index = 0;\n  var pipeIndex = -2;\n  var closeSquareIndex = -2;\n  var closeCurlyIndex = -2;\n  var closeParenIndex = -2;\n  var backSlashIndex = -2;\n  while (index < str.length) {\n    if (str[index] === '*') {\n      return true;\n    }\n    if (str[index + 1] === '?' && /[\\].+)]/.test(str[index])) {\n      return true;\n    }\n    if (closeSquareIndex !== -1 && str[index] === '[' && str[index + 1] !== ']') {\n      if (closeSquareIndex < index) {\n        closeSquareIndex = str.indexOf(']', index);\n      }\n      if (closeSquareIndex > index) {\n        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {\n          return true;\n        }\n        backSlashIndex = str.indexOf('\\\\', index);\n        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {\n          return true;\n        }\n      }\n    }\n    if (closeCurlyIndex !== -1 && str[index] === '{' && str[index + 1] !== '}') {\n      closeCurlyIndex = str.indexOf('}', index);\n      if (closeCurlyIndex > index) {\n        backSlashIndex = str.indexOf('\\\\', index);\n        if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {\n          return true;\n        }\n      }\n    }\n    if (closeParenIndex !== -1 && str[index] === '(' && str[index + 1] === '?' && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ')') {\n      closeParenIndex = str.indexOf(')', index);\n      if (closeParenIndex > index) {\n        backSlashIndex = str.indexOf('\\\\', index);\n        if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {\n          return true;\n        }\n      }\n    }\n    if (pipeIndex !== -1 && str[index] === '(' && str[index + 1] !== '|') {\n      if (pipeIndex < index) {\n        pipeIndex = str.indexOf('|', index);\n      }\n      if (pipeIndex !== -1 && str[pipeIndex + 1] !== ')') {\n        closeParenIndex = str.indexOf(')', pipeIndex);\n        if (closeParenIndex > pipeIndex) {\n          backSlashIndex = str.indexOf('\\\\', pipeIndex);\n          if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {\n            return true;\n          }\n        }\n      }\n    }\n    if (str[index] === '\\\\') {\n      var open = str[index + 1];\n      index += 2;\n      var close = chars[open];\n      if (close) {\n        var n = str.indexOf(close, index);\n        if (n !== -1) {\n          index = n + 1;\n        }\n      }\n      if (str[index] === '!') {\n        return true;\n      }\n    } else {\n      index++;\n    }\n  }\n  return false;\n};\nvar relaxedCheck = function (str) {\n  if (str[0] === '!') {\n    return true;\n  }\n  var index = 0;\n  while (index < str.length) {\n    if (/[*?{}()[\\]]/.test(str[index])) {\n      return true;\n    }\n    if (str[index] === '\\\\') {\n      var open = str[index + 1];\n      index += 2;\n      var close = chars[open];\n      if (close) {\n        var n = str.indexOf(close, index);\n        if (n !== -1) {\n          index = n + 1;\n        }\n      }\n      if (str[index] === '!') {\n        return true;\n      }\n    } else {\n      index++;\n    }\n  }\n  return false;\n};\nvar isGlob$2 = function isGlob(str, options) {\n  if (typeof str !== 'string' || str === '') {\n    return false;\n  }\n  if (isExtglob(str)) {\n    return true;\n  }\n  var check = strictCheck;\n\n  // optionally relax check\n  if (options && options.strict === false) {\n    check = relaxedCheck;\n  }\n  return check(str);\n};\nvar isGlob$1 = isGlob$2;\nvar pathPosixDirname = require$$0$2.posix.dirname;\nvar isWin32 = require$$2$1.platform() === 'win32';\nvar slash = '/';\nvar backslash = /\\\\/g;\nvar enclosure = /[\\{\\[].*[\\}\\]]$/;\nvar globby = /(^|[^\\\\])([\\{\\[]|\\([^\\)]+$)/;\nvar escaped = /\\\\([\\!\\*\\?\\|\\[\\]\\(\\)\\{\\}])/g;\n\n/**\n * @param {string} str\n * @param {Object} opts\n * @param {boolean} [opts.flipBackslashes=true]\n * @returns {string}\n */\nvar globParent$1 = function globParent(str, opts) {\n  var options = Object.assign({\n    flipBackslashes: true\n  }, opts);\n\n  // flip windows path separators\n  if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {\n    str = str.replace(backslash, slash);\n  }\n\n  // special case for strings ending in enclosure containing path separator\n  if (enclosure.test(str)) {\n    str += slash;\n  }\n\n  // preserves full path in case of trailing path separator\n  str += 'a';\n\n  // remove path parts that are globby\n  do {\n    str = pathPosixDirname(str);\n  } while (isGlob$1(str) || globby.test(str));\n\n  // remove escape chars and return result\n  return str.replace(escaped, '$1');\n};\nvar utils$3 = {};\n(function (exports) {\n  exports.isInteger = num => {\n    if (typeof num === 'number') {\n      return Number.isInteger(num);\n    }\n    if (typeof num === 'string' && num.trim() !== '') {\n      return Number.isInteger(Number(num));\n    }\n    return false;\n  };\n\n  /**\n   * Find a node of the given type\n   */\n\n  exports.find = (node, type) => node.nodes.find(node => node.type === type);\n\n  /**\n   * Find a node of the given type\n   */\n\n  exports.exceedsLimit = function (min, max) {\n    let step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    let limit = arguments.length > 3 ? arguments[3] : undefined;\n    if (limit === false) return false;\n    if (!exports.isInteger(min) || !exports.isInteger(max)) return false;\n    return (Number(max) - Number(min)) / Number(step) >= limit;\n  };\n\n  /**\n   * Escape the given node with '\\\\' before node.value\n   */\n\n  exports.escapeNode = function (block) {\n    let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let type = arguments.length > 2 ? arguments[2] : undefined;\n    let node = block.nodes[n];\n    if (!node) return;\n    if (type && node.type === type || node.type === 'open' || node.type === 'close') {\n      if (node.escaped !== true) {\n        node.value = '\\\\' + node.value;\n        node.escaped = true;\n      }\n    }\n  };\n\n  /**\n   * Returns true if the given brace node should be enclosed in literal braces\n   */\n\n  exports.encloseBrace = node => {\n    if (node.type !== 'brace') return false;\n    if (node.commas >> 0 + node.ranges >> 0 === 0) {\n      node.invalid = true;\n      return true;\n    }\n    return false;\n  };\n\n  /**\n   * Returns true if a brace node is invalid.\n   */\n\n  exports.isInvalidBrace = block => {\n    if (block.type !== 'brace') return false;\n    if (block.invalid === true || block.dollar) return true;\n    if (block.commas >> 0 + block.ranges >> 0 === 0) {\n      block.invalid = true;\n      return true;\n    }\n    if (block.open !== true || block.close !== true) {\n      block.invalid = true;\n      return true;\n    }\n    return false;\n  };\n\n  /**\n   * Returns true if a node is an open or close node\n   */\n\n  exports.isOpenOrClose = node => {\n    if (node.type === 'open' || node.type === 'close') {\n      return true;\n    }\n    return node.open === true || node.close === true;\n  };\n\n  /**\n   * Reduce an array of text nodes.\n   */\n\n  exports.reduce = nodes => nodes.reduce((acc, node) => {\n    if (node.type === 'text') acc.push(node.value);\n    if (node.type === 'range') node.type = 'text';\n    return acc;\n  }, []);\n\n  /**\n   * Flatten an array\n   */\n\n  exports.flatten = function () {\n    const result = [];\n    const flat = arr => {\n      for (let i = 0; i < arr.length; i++) {\n        let ele = arr[i];\n        Array.isArray(ele) ? flat(ele) : ele !== void 0 && result.push(ele);\n      }\n      return result;\n    };\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    flat(args);\n    return result;\n  };\n})(utils$3);\nconst utils$2 = utils$3;\nvar stringify$4 = function (ast) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let stringify = function (node) {\n    let parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let invalidBlock = options.escapeInvalid && utils$2.isInvalidBrace(parent);\n    let invalidNode = node.invalid === true && options.escapeInvalid === true;\n    let output = '';\n    if (node.value) {\n      if ((invalidBlock || invalidNode) && utils$2.isOpenOrClose(node)) {\n        return '\\\\' + node.value;\n      }\n      return node.value;\n    }\n    if (node.value) {\n      return node.value;\n    }\n    if (node.nodes) {\n      for (let child of node.nodes) {\n        output += stringify(child);\n      }\n    }\n    return output;\n  };\n  return stringify(ast);\n};\n\n/*!\n * is-number <https://github.com/jonschlinkert/is-number>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nvar isNumber$2 = function (num) {\n  if (typeof num === 'number') {\n    return num - num === 0;\n  }\n  if (typeof num === 'string' && num.trim() !== '') {\n    return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);\n  }\n  return false;\n};\n\n/*!\n * to-regex-range <https://github.com/micromatch/to-regex-range>\n *\n * Copyright (c) 2015-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nconst isNumber$1 = isNumber$2;\nconst toRegexRange$1 = (min, max, options) => {\n  if (isNumber$1(min) === false) {\n    throw new TypeError('toRegexRange: expected the first argument to be a number');\n  }\n  if (max === void 0 || min === max) {\n    return String(min);\n  }\n  if (isNumber$1(max) === false) {\n    throw new TypeError('toRegexRange: expected the second argument to be a number.');\n  }\n  let opts = {\n    relaxZeros: true,\n    ...options\n  };\n  if (typeof opts.strictZeros === 'boolean') {\n    opts.relaxZeros = opts.strictZeros === false;\n  }\n  let relax = String(opts.relaxZeros);\n  let shorthand = String(opts.shorthand);\n  let capture = String(opts.capture);\n  let wrap = String(opts.wrap);\n  let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;\n  if (toRegexRange$1.cache.hasOwnProperty(cacheKey)) {\n    return toRegexRange$1.cache[cacheKey].result;\n  }\n  let a = Math.min(min, max);\n  let b = Math.max(min, max);\n  if (Math.abs(a - b) === 1) {\n    let result = min + '|' + max;\n    if (opts.capture) {\n      return `(${result})`;\n    }\n    if (opts.wrap === false) {\n      return result;\n    }\n    return `(?:${result})`;\n  }\n  let isPadded = hasPadding(min) || hasPadding(max);\n  let state = {\n    min,\n    max,\n    a,\n    b\n  };\n  let positives = [];\n  let negatives = [];\n  if (isPadded) {\n    state.isPadded = isPadded;\n    state.maxLen = String(state.max).length;\n  }\n  if (a < 0) {\n    let newMin = b < 0 ? Math.abs(b) : 1;\n    negatives = splitToPatterns(newMin, Math.abs(a), state, opts);\n    a = state.a = 0;\n  }\n  if (b >= 0) {\n    positives = splitToPatterns(a, b, state, opts);\n  }\n  state.negatives = negatives;\n  state.positives = positives;\n  state.result = collatePatterns(negatives, positives);\n  if (opts.capture === true) {\n    state.result = `(${state.result})`;\n  } else if (opts.wrap !== false && positives.length + negatives.length > 1) {\n    state.result = `(?:${state.result})`;\n  }\n  toRegexRange$1.cache[cacheKey] = state;\n  return state.result;\n};\nfunction collatePatterns(neg, pos, options) {\n  let onlyNegative = filterPatterns(neg, pos, '-', false) || [];\n  let onlyPositive = filterPatterns(pos, neg, '', false) || [];\n  let intersected = filterPatterns(neg, pos, '-?', true) || [];\n  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);\n  return subpatterns.join('|');\n}\nfunction splitToRanges(min, max) {\n  let nines = 1;\n  let zeros = 1;\n  let stop = countNines(min, nines);\n  let stops = new Set([max]);\n  while (min <= stop && stop <= max) {\n    stops.add(stop);\n    nines += 1;\n    stop = countNines(min, nines);\n  }\n  stop = countZeros(max + 1, zeros) - 1;\n  while (min < stop && stop <= max) {\n    stops.add(stop);\n    zeros += 1;\n    stop = countZeros(max + 1, zeros) - 1;\n  }\n  stops = [...stops];\n  stops.sort(compare);\n  return stops;\n}\n\n/**\n * Convert a range to a regex pattern\n * @param {Number} `start`\n * @param {Number} `stop`\n * @return {String}\n */\n\nfunction rangeToPattern(start, stop, options) {\n  if (start === stop) {\n    return {\n      pattern: start,\n      count: [],\n      digits: 0\n    };\n  }\n  let zipped = zip(start, stop);\n  let digits = zipped.length;\n  let pattern = '';\n  let count = 0;\n  for (let i = 0; i < digits; i++) {\n    let [startDigit, stopDigit] = zipped[i];\n    if (startDigit === stopDigit) {\n      pattern += startDigit;\n    } else if (startDigit !== '0' || stopDigit !== '9') {\n      pattern += toCharacterClass(startDigit, stopDigit);\n    } else {\n      count++;\n    }\n  }\n  if (count) {\n    pattern += options.shorthand === true ? '\\\\d' : '[0-9]';\n  }\n  return {\n    pattern,\n    count: [count],\n    digits\n  };\n}\nfunction splitToPatterns(min, max, tok, options) {\n  let ranges = splitToRanges(min, max);\n  let tokens = [];\n  let start = min;\n  let prev;\n  for (let i = 0; i < ranges.length; i++) {\n    let max = ranges[i];\n    let obj = rangeToPattern(String(start), String(max), options);\n    let zeros = '';\n    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {\n      if (prev.count.length > 1) {\n        prev.count.pop();\n      }\n      prev.count.push(obj.count[0]);\n      prev.string = prev.pattern + toQuantifier(prev.count);\n      start = max + 1;\n      continue;\n    }\n    if (tok.isPadded) {\n      zeros = padZeros(max, tok, options);\n    }\n    obj.string = zeros + obj.pattern + toQuantifier(obj.count);\n    tokens.push(obj);\n    start = max + 1;\n    prev = obj;\n  }\n  return tokens;\n}\nfunction filterPatterns(arr, comparison, prefix, intersection, options) {\n  let result = [];\n  for (let ele of arr) {\n    let {\n      string\n    } = ele;\n\n    // only push if _both_ are negative...\n    if (!intersection && !contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    }\n\n    // or _both_ are positive\n    if (intersection && contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    }\n  }\n  return result;\n}\n\n/**\n * Zip strings\n */\n\nfunction zip(a, b) {\n  let arr = [];\n  for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);\n  return arr;\n}\nfunction compare(a, b) {\n  return a > b ? 1 : b > a ? -1 : 0;\n}\nfunction contains(arr, key, val) {\n  return arr.some(ele => ele[key] === val);\n}\nfunction countNines(min, len) {\n  return Number(String(min).slice(0, -len) + '9'.repeat(len));\n}\nfunction countZeros(integer, zeros) {\n  return integer - integer % Math.pow(10, zeros);\n}\nfunction toQuantifier(digits) {\n  let [start = 0, stop = ''] = digits;\n  if (stop || start > 1) {\n    return `{${start + (stop ? ',' + stop : '')}}`;\n  }\n  return '';\n}\nfunction toCharacterClass(a, b, options) {\n  return `[${a}${b - a === 1 ? '' : '-'}${b}]`;\n}\nfunction hasPadding(str) {\n  return /^-?(0+)\\d/.test(str);\n}\nfunction padZeros(value, tok, options) {\n  if (!tok.isPadded) {\n    return value;\n  }\n  let diff = Math.abs(tok.maxLen - String(value).length);\n  let relax = options.relaxZeros !== false;\n  switch (diff) {\n    case 0:\n      return '';\n    case 1:\n      return relax ? '0?' : '0';\n    case 2:\n      return relax ? '0{0,2}' : '00';\n    default:\n      {\n        return relax ? `0{0,${diff}}` : `0{${diff}}`;\n      }\n  }\n}\n\n/**\n * Cache\n */\n\ntoRegexRange$1.cache = {};\ntoRegexRange$1.clearCache = () => toRegexRange$1.cache = {};\n\n/**\n * Expose `toRegexRange`\n */\n\nvar toRegexRange_1 = toRegexRange$1;\n\n/*!\n * fill-range <https://github.com/jonschlinkert/fill-range>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\nconst util = require$$2;\nconst toRegexRange = toRegexRange_1;\nconst isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\nconst transform = toNumber => {\n  return value => toNumber === true ? Number(value) : String(value);\n};\nconst isValidValue = value => {\n  return typeof value === 'number' || typeof value === 'string' && value !== '';\n};\nconst isNumber = num => Number.isInteger(+num);\nconst zeros = input => {\n  let value = `${input}`;\n  let index = -1;\n  if (value[0] === '-') value = value.slice(1);\n  if (value === '0') return false;\n  while (value[++index] === '0');\n  return index > 0;\n};\nconst stringify$3 = (start, end, options) => {\n  if (typeof start === 'string' || typeof end === 'string') {\n    return true;\n  }\n  return options.stringify === true;\n};\nconst pad = (input, maxLength, toNumber) => {\n  if (maxLength > 0) {\n    let dash = input[0] === '-' ? '-' : '';\n    if (dash) input = input.slice(1);\n    input = dash + input.padStart(dash ? maxLength - 1 : maxLength, '0');\n  }\n  if (toNumber === false) {\n    return String(input);\n  }\n  return input;\n};\nconst toMaxLen = (input, maxLength) => {\n  let negative = input[0] === '-' ? '-' : '';\n  if (negative) {\n    input = input.slice(1);\n    maxLength--;\n  }\n  while (input.length < maxLength) input = '0' + input;\n  return negative ? '-' + input : input;\n};\nconst toSequence = (parts, options) => {\n  parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n  parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n  let prefix = options.capture ? '' : '?:';\n  let positives = '';\n  let negatives = '';\n  let result;\n  if (parts.positives.length) {\n    positives = parts.positives.join('|');\n  }\n  if (parts.negatives.length) {\n    negatives = `-(${prefix}${parts.negatives.join('|')})`;\n  }\n  if (positives && negatives) {\n    result = `${positives}|${negatives}`;\n  } else {\n    result = positives || negatives;\n  }\n  if (options.wrap) {\n    return `(${prefix}${result})`;\n  }\n  return result;\n};\nconst toRange = (a, b, isNumbers, options) => {\n  if (isNumbers) {\n    return toRegexRange(a, b, {\n      wrap: false,\n      ...options\n    });\n  }\n  let start = String.fromCharCode(a);\n  if (a === b) return start;\n  let stop = String.fromCharCode(b);\n  return `[${start}-${stop}]`;\n};\nconst toRegex = (start, end, options) => {\n  if (Array.isArray(start)) {\n    let wrap = options.wrap === true;\n    let prefix = options.capture ? '' : '?:';\n    return wrap ? `(${prefix}${start.join('|')})` : start.join('|');\n  }\n  return toRegexRange(start, end, options);\n};\nconst rangeError = function () {\n  return new RangeError('Invalid range arguments: ' + util.inspect(...arguments));\n};\nconst invalidRange = (start, end, options) => {\n  if (options.strictRanges === true) throw rangeError([start, end]);\n  return [];\n};\nconst invalidStep = (step, options) => {\n  if (options.strictRanges === true) {\n    throw new TypeError(`Expected step \"${step}\" to be a number`);\n  }\n  return [];\n};\nconst fillNumbers = function (start, end) {\n  let step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  let a = Number(start);\n  let b = Number(end);\n  if (!Number.isInteger(a) || !Number.isInteger(b)) {\n    if (options.strictRanges === true) throw rangeError([start, end]);\n    return [];\n  }\n\n  // fix negative zero\n  if (a === 0) a = 0;\n  if (b === 0) b = 0;\n  let descending = a > b;\n  let startString = String(start);\n  let endString = String(end);\n  let stepString = String(step);\n  step = Math.max(Math.abs(step), 1);\n  let padded = zeros(startString) || zeros(endString) || zeros(stepString);\n  let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;\n  let toNumber = padded === false && stringify$3(start, end, options) === false;\n  let format = options.transform || transform(toNumber);\n  if (options.toRegex && step === 1) {\n    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);\n  }\n  let parts = {\n    negatives: [],\n    positives: []\n  };\n  let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));\n  let range = [];\n  let index = 0;\n  while (descending ? a >= b : a <= b) {\n    if (options.toRegex === true && step > 1) {\n      push(a);\n    } else {\n      range.push(pad(format(a, index), maxLen, toNumber));\n    }\n    a = descending ? a - step : a + step;\n    index++;\n  }\n  if (options.toRegex === true) {\n    return step > 1 ? toSequence(parts, options) : toRegex(range, null, {\n      wrap: false,\n      ...options\n    });\n  }\n  return range;\n};\nconst fillLetters = function (start, end) {\n  let step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {\n    return invalidRange(start, end, options);\n  }\n  let format = options.transform || (val => String.fromCharCode(val));\n  let a = `${start}`.charCodeAt(0);\n  let b = `${end}`.charCodeAt(0);\n  let descending = a > b;\n  let min = Math.min(a, b);\n  let max = Math.max(a, b);\n  if (options.toRegex && step === 1) {\n    return toRange(min, max, false, options);\n  }\n  let range = [];\n  let index = 0;\n  while (descending ? a >= b : a <= b) {\n    range.push(format(a, index));\n    a = descending ? a - step : a + step;\n    index++;\n  }\n  if (options.toRegex === true) {\n    return toRegex(range, null, {\n      wrap: false,\n      options\n    });\n  }\n  return range;\n};\nconst fill$2 = function (start, end, step) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  if (end == null && isValidValue(start)) {\n    return [start];\n  }\n  if (!isValidValue(start) || !isValidValue(end)) {\n    return invalidRange(start, end, options);\n  }\n  if (typeof step === 'function') {\n    return fill$2(start, end, 1, {\n      transform: step\n    });\n  }\n  if (isObject(step)) {\n    return fill$2(start, end, 0, step);\n  }\n  let opts = {\n    ...options\n  };\n  if (opts.capture === true) opts.wrap = true;\n  step = step || opts.step || 1;\n  if (!isNumber(step)) {\n    if (step != null && !isObject(step)) return invalidStep(step, opts);\n    return fill$2(start, end, 1, step);\n  }\n  if (isNumber(start) && isNumber(end)) {\n    return fillNumbers(start, end, step, opts);\n  }\n  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);\n};\nvar fillRange = fill$2;\nconst fill$1 = fillRange;\nconst utils$1 = utils$3;\nconst compile$1 = function (ast) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let walk = function (node) {\n    let parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let invalidBlock = utils$1.isInvalidBrace(parent);\n    let invalidNode = node.invalid === true && options.escapeInvalid === true;\n    let invalid = invalidBlock === true || invalidNode === true;\n    let prefix = options.escapeInvalid === true ? '\\\\' : '';\n    let output = '';\n    if (node.isOpen === true) {\n      return prefix + node.value;\n    }\n    if (node.isClose === true) {\n      return prefix + node.value;\n    }\n    if (node.type === 'open') {\n      return invalid ? prefix + node.value : '(';\n    }\n    if (node.type === 'close') {\n      return invalid ? prefix + node.value : ')';\n    }\n    if (node.type === 'comma') {\n      return node.prev.type === 'comma' ? '' : invalid ? node.value : '|';\n    }\n    if (node.value) {\n      return node.value;\n    }\n    if (node.nodes && node.ranges > 0) {\n      let args = utils$1.reduce(node.nodes);\n      let range = fill$1(...args, {\n        ...options,\n        wrap: false,\n        toRegex: true\n      });\n      if (range.length !== 0) {\n        return args.length > 1 && range.length > 1 ? `(${range})` : range;\n      }\n    }\n    if (node.nodes) {\n      for (let child of node.nodes) {\n        output += walk(child, node);\n      }\n    }\n    return output;\n  };\n  return walk(ast);\n};\nvar compile_1 = compile$1;\nconst fill = fillRange;\nconst stringify$2 = stringify$4;\nconst utils = utils$3;\nconst append = function () {\n  let queue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  let stash = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  let enclose = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  let result = [];\n  queue = [].concat(queue);\n  stash = [].concat(stash);\n  if (!stash.length) return queue;\n  if (!queue.length) {\n    return enclose ? utils.flatten(stash).map(ele => `{${ele}}`) : stash;\n  }\n  for (let item of queue) {\n    if (Array.isArray(item)) {\n      for (let value of item) {\n        result.push(append(value, stash, enclose));\n      }\n    } else {\n      for (let ele of stash) {\n        if (enclose === true && typeof ele === 'string') ele = `{${ele}}`;\n        result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);\n      }\n    }\n  }\n  return utils.flatten(result);\n};\nconst expand$1 = function (ast) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let rangeLimit = options.rangeLimit === void 0 ? 1000 : options.rangeLimit;\n  let walk = function (node) {\n    let parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    node.queue = [];\n    let p = parent;\n    let q = parent.queue;\n    while (p.type !== 'brace' && p.type !== 'root' && p.parent) {\n      p = p.parent;\n      q = p.queue;\n    }\n    if (node.invalid || node.dollar) {\n      q.push(append(q.pop(), stringify$2(node, options)));\n      return;\n    }\n    if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {\n      q.push(append(q.pop(), ['{}']));\n      return;\n    }\n    if (node.nodes && node.ranges > 0) {\n      let args = utils.reduce(node.nodes);\n      if (utils.exceedsLimit(...args, options.step, rangeLimit)) {\n        throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');\n      }\n      let range = fill(...args, options);\n      if (range.length === 0) {\n        range = stringify$2(node, options);\n      }\n      q.push(append(q.pop(), range));\n      node.nodes = [];\n      return;\n    }\n    let enclose = utils.encloseBrace(node);\n    let queue = node.queue;\n    let block = node;\n    while (block.type !== 'brace' && block.type !== 'root' && block.parent) {\n      block = block.parent;\n      queue = block.queue;\n    }\n    for (let i = 0; i < node.nodes.length; i++) {\n      let child = node.nodes[i];\n      if (child.type === 'comma' && node.type === 'brace') {\n        if (i === 1) queue.push('');\n        queue.push('');\n        continue;\n      }\n      if (child.type === 'close') {\n        q.push(append(q.pop(), queue, enclose));\n        continue;\n      }\n      if (child.value && child.type !== 'open') {\n        queue.push(append(queue.pop(), child.value));\n        continue;\n      }\n      if (child.nodes) {\n        walk(child, node);\n      }\n    }\n    return queue;\n  };\n  return utils.flatten(walk(ast));\n};\nvar expand_1 = expand$1;\nvar constants$1 = {\n  MAX_LENGTH: 1024 * 64,\n  // Digits\n  CHAR_0: '0',\n  /* 0 */\n  CHAR_9: '9',\n  /* 9 */\n\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 'A',\n  /* A */\n  CHAR_LOWERCASE_A: 'a',\n  /* a */\n  CHAR_UPPERCASE_Z: 'Z',\n  /* Z */\n  CHAR_LOWERCASE_Z: 'z',\n  /* z */\n\n  CHAR_LEFT_PARENTHESES: '(',\n  /* ( */\n  CHAR_RIGHT_PARENTHESES: ')',\n  /* ) */\n\n  CHAR_ASTERISK: '*',\n  /* * */\n\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: '&',\n  /* & */\n  CHAR_AT: '@',\n  /* @ */\n  CHAR_BACKSLASH: '\\\\',\n  /* \\ */\n  CHAR_BACKTICK: '`',\n  /* ` */\n  CHAR_CARRIAGE_RETURN: '\\r',\n  /* \\r */\n  CHAR_CIRCUMFLEX_ACCENT: '^',\n  /* ^ */\n  CHAR_COLON: ':',\n  /* : */\n  CHAR_COMMA: ',',\n  /* , */\n  CHAR_DOLLAR: '$',\n  /* . */\n  CHAR_DOT: '.',\n  /* . */\n  CHAR_DOUBLE_QUOTE: '\"',\n  /* \" */\n  CHAR_EQUAL: '=',\n  /* = */\n  CHAR_EXCLAMATION_MARK: '!',\n  /* ! */\n  CHAR_FORM_FEED: '\\f',\n  /* \\f */\n  CHAR_FORWARD_SLASH: '/',\n  /* / */\n  CHAR_HASH: '#',\n  /* # */\n  CHAR_HYPHEN_MINUS: '-',\n  /* - */\n  CHAR_LEFT_ANGLE_BRACKET: '<',\n  /* < */\n  CHAR_LEFT_CURLY_BRACE: '{',\n  /* { */\n  CHAR_LEFT_SQUARE_BRACKET: '[',\n  /* [ */\n  CHAR_LINE_FEED: '\\n',\n  /* \\n */\n  CHAR_NO_BREAK_SPACE: '\\u00A0',\n  /* \\u00A0 */\n  CHAR_PERCENT: '%',\n  /* % */\n  CHAR_PLUS: '+',\n  /* + */\n  CHAR_QUESTION_MARK: '?',\n  /* ? */\n  CHAR_RIGHT_ANGLE_BRACKET: '>',\n  /* > */\n  CHAR_RIGHT_CURLY_BRACE: '}',\n  /* } */\n  CHAR_RIGHT_SQUARE_BRACKET: ']',\n  /* ] */\n  CHAR_SEMICOLON: ';',\n  /* ; */\n  CHAR_SINGLE_QUOTE: '\\'',\n  /* ' */\n  CHAR_SPACE: ' ',\n  /*   */\n  CHAR_TAB: '\\t',\n  /* \\t */\n  CHAR_UNDERSCORE: '_',\n  /* _ */\n  CHAR_VERTICAL_LINE: '|',\n  /* | */\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\\uFEFF' /* \\uFEFF */\n};\n\nconst stringify$1 = stringify$4;\n\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  CHAR_BACKSLASH,\n  /* \\ */\n  CHAR_BACKTICK,\n  /* ` */\n  CHAR_COMMA,\n  /* , */\n  CHAR_DOT,\n  /* . */\n  CHAR_LEFT_PARENTHESES,\n  /* ( */\n  CHAR_RIGHT_PARENTHESES,\n  /* ) */\n  CHAR_LEFT_CURLY_BRACE,\n  /* { */\n  CHAR_RIGHT_CURLY_BRACE,\n  /* } */\n  CHAR_LEFT_SQUARE_BRACKET,\n  /* [ */\n  CHAR_RIGHT_SQUARE_BRACKET,\n  /* ] */\n  CHAR_DOUBLE_QUOTE,\n  /* \" */\n  CHAR_SINGLE_QUOTE,\n  /* ' */\n  CHAR_NO_BREAK_SPACE,\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE\n} = constants$1;\n\n/**\n * parse\n */\n\nconst parse$1 = function (input) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n  let opts = options || {};\n  let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  if (input.length > max) {\n    throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);\n  }\n  let ast = {\n    type: 'root',\n    input,\n    nodes: []\n  };\n  let stack = [ast];\n  let block = ast;\n  let prev = ast;\n  let brackets = 0;\n  let length = input.length;\n  let index = 0;\n  let depth = 0;\n  let value;\n\n  /**\n   * Helpers\n   */\n\n  const advance = () => input[index++];\n  const push = node => {\n    if (node.type === 'text' && prev.type === 'dot') {\n      prev.type = 'text';\n    }\n    if (prev && prev.type === 'text' && node.type === 'text') {\n      prev.value += node.value;\n      return;\n    }\n    block.nodes.push(node);\n    node.parent = block;\n    node.prev = prev;\n    prev = node;\n    return node;\n  };\n  push({\n    type: 'bos'\n  });\n  while (index < length) {\n    block = stack[stack.length - 1];\n    value = advance();\n\n    /**\n     * Invalid chars\n     */\n\n    if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {\n      continue;\n    }\n\n    /**\n     * Escaped chars\n     */\n\n    if (value === CHAR_BACKSLASH) {\n      push({\n        type: 'text',\n        value: (options.keepEscaping ? value : '') + advance()\n      });\n      continue;\n    }\n\n    /**\n     * Right square bracket (literal): ']'\n     */\n\n    if (value === CHAR_RIGHT_SQUARE_BRACKET) {\n      push({\n        type: 'text',\n        value: '\\\\' + value\n      });\n      continue;\n    }\n\n    /**\n     * Left square bracket: '['\n     */\n\n    if (value === CHAR_LEFT_SQUARE_BRACKET) {\n      brackets++;\n      let next;\n      while (index < length && (next = advance())) {\n        value += next;\n        if (next === CHAR_LEFT_SQUARE_BRACKET) {\n          brackets++;\n          continue;\n        }\n        if (next === CHAR_BACKSLASH) {\n          value += advance();\n          continue;\n        }\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          brackets--;\n          if (brackets === 0) {\n            break;\n          }\n        }\n      }\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === CHAR_LEFT_PARENTHESES) {\n      block = push({\n        type: 'paren',\n        nodes: []\n      });\n      stack.push(block);\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n    if (value === CHAR_RIGHT_PARENTHESES) {\n      if (block.type !== 'paren') {\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      }\n      block = stack.pop();\n      push({\n        type: 'text',\n        value\n      });\n      block = stack[stack.length - 1];\n      continue;\n    }\n\n    /**\n     * Quotes: '|\"|`\n     */\n\n    if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {\n      let open = value;\n      let next;\n      if (options.keepQuotes !== true) {\n        value = '';\n      }\n      while (index < length && (next = advance())) {\n        if (next === CHAR_BACKSLASH) {\n          value += next + advance();\n          continue;\n        }\n        if (next === open) {\n          if (options.keepQuotes === true) value += next;\n          break;\n        }\n        value += next;\n      }\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n\n    /**\n     * Left curly brace: '{'\n     */\n\n    if (value === CHAR_LEFT_CURLY_BRACE) {\n      depth++;\n      let dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;\n      let brace = {\n        type: 'brace',\n        open: true,\n        close: false,\n        dollar,\n        depth,\n        commas: 0,\n        ranges: 0,\n        nodes: []\n      };\n      block = push(brace);\n      stack.push(block);\n      push({\n        type: 'open',\n        value\n      });\n      continue;\n    }\n\n    /**\n     * Right curly brace: '}'\n     */\n\n    if (value === CHAR_RIGHT_CURLY_BRACE) {\n      if (block.type !== 'brace') {\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      }\n      let type = 'close';\n      block = stack.pop();\n      block.close = true;\n      push({\n        type,\n        value\n      });\n      depth--;\n      block = stack[stack.length - 1];\n      continue;\n    }\n\n    /**\n     * Comma: ','\n     */\n\n    if (value === CHAR_COMMA && depth > 0) {\n      if (block.ranges > 0) {\n        block.ranges = 0;\n        let open = block.nodes.shift();\n        block.nodes = [open, {\n          type: 'text',\n          value: stringify$1(block)\n        }];\n      }\n      push({\n        type: 'comma',\n        value\n      });\n      block.commas++;\n      continue;\n    }\n\n    /**\n     * Dot: '.'\n     */\n\n    if (value === CHAR_DOT && depth > 0 && block.commas === 0) {\n      let siblings = block.nodes;\n      if (depth === 0 || siblings.length === 0) {\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      }\n      if (prev.type === 'dot') {\n        block.range = [];\n        prev.value += value;\n        prev.type = 'range';\n        if (block.nodes.length !== 3 && block.nodes.length !== 5) {\n          block.invalid = true;\n          block.ranges = 0;\n          prev.type = 'text';\n          continue;\n        }\n        block.ranges++;\n        block.args = [];\n        continue;\n      }\n      if (prev.type === 'range') {\n        siblings.pop();\n        let before = siblings[siblings.length - 1];\n        before.value += prev.value + value;\n        prev = before;\n        block.ranges--;\n        continue;\n      }\n      push({\n        type: 'dot',\n        value\n      });\n      continue;\n    }\n\n    /**\n     * Text\n     */\n\n    push({\n      type: 'text',\n      value\n    });\n  }\n\n  // Mark imbalanced braces and brackets as invalid\n  do {\n    block = stack.pop();\n    if (block.type !== 'root') {\n      block.nodes.forEach(node => {\n        if (!node.nodes) {\n          if (node.type === 'open') node.isOpen = true;\n          if (node.type === 'close') node.isClose = true;\n          if (!node.nodes) node.type = 'text';\n          node.invalid = true;\n        }\n      });\n\n      // get the location of the block on parent.nodes (block's siblings)\n      let parent = stack[stack.length - 1];\n      let index = parent.nodes.indexOf(block);\n      // replace the (invalid) block with it's nodes\n      parent.nodes.splice(index, 1, ...block.nodes);\n    }\n  } while (stack.length > 0);\n  push({\n    type: 'eos'\n  });\n  return ast;\n};\nvar parse_1 = parse$1;\nconst stringify = stringify$4;\nconst compile = compile_1;\nconst expand = expand_1;\nconst parse = parse_1;\n\n/**\n * Expand the given pattern or create a regex-compatible string.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']\n * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {String}\n * @api public\n */\n\nconst braces$1 = function (input) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let output = [];\n  if (Array.isArray(input)) {\n    for (let pattern of input) {\n      let result = braces$1.create(pattern, options);\n      if (Array.isArray(result)) {\n        output.push(...result);\n      } else {\n        output.push(result);\n      }\n    }\n  } else {\n    output = [].concat(braces$1.create(input, options));\n  }\n  if (options && options.expand === true && options.nodupes === true) {\n    output = [...new Set(output)];\n  }\n  return output;\n};\n\n/**\n * Parse the given `str` with the given `options`.\n *\n * ```js\n * // braces.parse(pattern, [, options]);\n * const ast = braces.parse('a/{b,c}/d');\n * console.log(ast);\n * ```\n * @param {String} pattern Brace pattern to parse\n * @param {Object} options\n * @return {Object} Returns an AST\n * @api public\n */\n\nbraces$1.parse = function (input) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return parse(input, options);\n};\n\n/**\n * Creates a braces string from an AST, or an AST node.\n *\n * ```js\n * const braces = require('braces');\n * let ast = braces.parse('foo/{a,b}/bar');\n * console.log(stringify(ast.nodes[2])); //=> '{a,b}'\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces$1.stringify = function (input) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (typeof input === 'string') {\n    return stringify(braces$1.parse(input, options), options);\n  }\n  return stringify(input, options);\n};\n\n/**\n * Compiles a brace pattern into a regex-compatible, optimized string.\n * This method is called by the main [braces](#braces) function by default.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.compile('a/{b,c}/d'));\n * //=> ['a/(b|c)/d']\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces$1.compile = function (input) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (typeof input === 'string') {\n    input = braces$1.parse(input, options);\n  }\n  return compile(input, options);\n};\n\n/**\n * Expands a brace pattern into an array. This method is called by the\n * main [braces](#braces) function when `options.expand` is true. Before\n * using this method it's recommended that you read the [performance notes](#performance))\n * and advantages of using [.compile](#compile) instead.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.expand('a/{b,c}/d'));\n * //=> ['a/b/d', 'a/c/d'];\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces$1.expand = function (input) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (typeof input === 'string') {\n    input = braces$1.parse(input, options);\n  }\n  let result = expand(input, options);\n\n  // filter out empty strings if specified\n  if (options.noempty === true) {\n    result = result.filter(Boolean);\n  }\n\n  // filter out duplicates if specified\n  if (options.nodupes === true) {\n    result = [...new Set(result)];\n  }\n  return result;\n};\n\n/**\n * Processes a brace pattern and returns either an expanded array\n * (if `options.expand` is true), a highly optimized regex-compatible string.\n * This method is called by the main [braces](#braces) function.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))\n * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces$1.create = function (input) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (input === '' || input.length < 3) {\n    return [input];\n  }\n  return options.expand !== true ? braces$1.compile(input, options) : braces$1.expand(input, options);\n};\n\n/**\n * Expose \"braces\"\n */\n\nvar braces_1 = braces$1;\nvar binaryExtensionsExports = {};\nvar binaryExtensions$1 = {\n  get exports() {\n    return binaryExtensionsExports;\n  },\n  set exports(v) {\n    binaryExtensionsExports = v;\n  }\n};\nconst require$$0 = [\"3dm\", \"3ds\", \"3g2\", \"3gp\", \"7z\", \"a\", \"aac\", \"adp\", \"ai\", \"aif\", \"aiff\", \"alz\", \"ape\", \"apk\", \"appimage\", \"ar\", \"arj\", \"asf\", \"au\", \"avi\", \"bak\", \"baml\", \"bh\", \"bin\", \"bk\", \"bmp\", \"btif\", \"bz2\", \"bzip2\", \"cab\", \"caf\", \"cgm\", \"class\", \"cmx\", \"cpio\", \"cr2\", \"cur\", \"dat\", \"dcm\", \"deb\", \"dex\", \"djvu\", \"dll\", \"dmg\", \"dng\", \"doc\", \"docm\", \"docx\", \"dot\", \"dotm\", \"dra\", \"DS_Store\", \"dsk\", \"dts\", \"dtshd\", \"dvb\", \"dwg\", \"dxf\", \"ecelp4800\", \"ecelp7470\", \"ecelp9600\", \"egg\", \"eol\", \"eot\", \"epub\", \"exe\", \"f4v\", \"fbs\", \"fh\", \"fla\", \"flac\", \"flatpak\", \"fli\", \"flv\", \"fpx\", \"fst\", \"fvt\", \"g3\", \"gh\", \"gif\", \"graffle\", \"gz\", \"gzip\", \"h261\", \"h263\", \"h264\", \"icns\", \"ico\", \"ief\", \"img\", \"ipa\", \"iso\", \"jar\", \"jpeg\", \"jpg\", \"jpgv\", \"jpm\", \"jxr\", \"key\", \"ktx\", \"lha\", \"lib\", \"lvp\", \"lz\", \"lzh\", \"lzma\", \"lzo\", \"m3u\", \"m4a\", \"m4v\", \"mar\", \"mdi\", \"mht\", \"mid\", \"midi\", \"mj2\", \"mka\", \"mkv\", \"mmr\", \"mng\", \"mobi\", \"mov\", \"movie\", \"mp3\", \"mp4\", \"mp4a\", \"mpeg\", \"mpg\", \"mpga\", \"mxu\", \"nef\", \"npx\", \"numbers\", \"nupkg\", \"o\", \"odp\", \"ods\", \"odt\", \"oga\", \"ogg\", \"ogv\", \"otf\", \"ott\", \"pages\", \"pbm\", \"pcx\", \"pdb\", \"pdf\", \"pea\", \"pgm\", \"pic\", \"png\", \"pnm\", \"pot\", \"potm\", \"potx\", \"ppa\", \"ppam\", \"ppm\", \"pps\", \"ppsm\", \"ppsx\", \"ppt\", \"pptm\", \"pptx\", \"psd\", \"pya\", \"pyc\", \"pyo\", \"pyv\", \"qt\", \"rar\", \"ras\", \"raw\", \"resources\", \"rgb\", \"rip\", \"rlc\", \"rmf\", \"rmvb\", \"rpm\", \"rtf\", \"rz\", \"s3m\", \"s7z\", \"scpt\", \"sgi\", \"shar\", \"snap\", \"sil\", \"sketch\", \"slk\", \"smv\", \"snk\", \"so\", \"stl\", \"suo\", \"sub\", \"swf\", \"tar\", \"tbz\", \"tbz2\", \"tga\", \"tgz\", \"thmx\", \"tif\", \"tiff\", \"tlz\", \"ttc\", \"ttf\", \"txz\", \"udf\", \"uvh\", \"uvi\", \"uvm\", \"uvp\", \"uvs\", \"uvu\", \"viv\", \"vob\", \"war\", \"wav\", \"wax\", \"wbmp\", \"wdp\", \"weba\", \"webm\", \"webp\", \"whl\", \"wim\", \"wm\", \"wma\", \"wmv\", \"wmx\", \"woff\", \"woff2\", \"wrm\", \"wvx\", \"xbm\", \"xif\", \"xla\", \"xlam\", \"xls\", \"xlsb\", \"xlsm\", \"xlsx\", \"xlt\", \"xltm\", \"xltx\", \"xm\", \"xmind\", \"xpi\", \"xpm\", \"xwd\", \"xz\", \"z\", \"zip\", \"zipx\"];\n(function (module) {\n  module.exports = require$$0;\n})(binaryExtensions$1);\nconst path = require$$0$2;\nconst binaryExtensions = binaryExtensionsExports;\nconst extensions = new Set(binaryExtensions);\nvar isBinaryPath$1 = filePath => extensions.has(path.extname(filePath).slice(1).toLowerCase());\nvar constants = {};\n(function (exports) {\n  const {\n    sep\n  } = require$$0$2;\n  const {\n    platform\n  } = process;\n  const os = require$$2$1;\n  exports.EV_ALL = 'all';\n  exports.EV_READY = 'ready';\n  exports.EV_ADD = 'add';\n  exports.EV_CHANGE = 'change';\n  exports.EV_ADD_DIR = 'addDir';\n  exports.EV_UNLINK = 'unlink';\n  exports.EV_UNLINK_DIR = 'unlinkDir';\n  exports.EV_RAW = 'raw';\n  exports.EV_ERROR = 'error';\n  exports.STR_DATA = 'data';\n  exports.STR_END = 'end';\n  exports.STR_CLOSE = 'close';\n  exports.FSEVENT_CREATED = 'created';\n  exports.FSEVENT_MODIFIED = 'modified';\n  exports.FSEVENT_DELETED = 'deleted';\n  exports.FSEVENT_MOVED = 'moved';\n  exports.FSEVENT_CLONED = 'cloned';\n  exports.FSEVENT_UNKNOWN = 'unknown';\n  exports.FSEVENT_TYPE_FILE = 'file';\n  exports.FSEVENT_TYPE_DIRECTORY = 'directory';\n  exports.FSEVENT_TYPE_SYMLINK = 'symlink';\n  exports.KEY_LISTENERS = 'listeners';\n  exports.KEY_ERR = 'errHandlers';\n  exports.KEY_RAW = 'rawEmitters';\n  exports.HANDLER_KEYS = [exports.KEY_LISTENERS, exports.KEY_ERR, exports.KEY_RAW];\n  exports.DOT_SLASH = `.${sep}`;\n  exports.BACK_SLASH_RE = /\\\\/g;\n  exports.DOUBLE_SLASH_RE = /\\/\\//;\n  exports.SLASH_OR_BACK_SLASH_RE = /[/\\\\]/;\n  exports.DOT_RE = /\\..*\\.(sw[px])$|~$|\\.subl.*\\.tmp/;\n  exports.REPLACER_RE = /^\\.[/\\\\]/;\n  exports.SLASH = '/';\n  exports.SLASH_SLASH = '//';\n  exports.BRACE_START = '{';\n  exports.BANG = '!';\n  exports.ONE_DOT = '.';\n  exports.TWO_DOTS = '..';\n  exports.STAR = '*';\n  exports.GLOBSTAR = '**';\n  exports.ROOT_GLOBSTAR = '/**/*';\n  exports.SLASH_GLOBSTAR = '/**';\n  exports.DIR_SUFFIX = 'Dir';\n  exports.ANYMATCH_OPTS = {\n    dot: true\n  };\n  exports.STRING_TYPE = 'string';\n  exports.FUNCTION_TYPE = 'function';\n  exports.EMPTY_STR = '';\n  exports.EMPTY_FN = () => {};\n  exports.IDENTITY_FN = val => val;\n  exports.isWindows = platform === 'win32';\n  exports.isMacos = platform === 'darwin';\n  exports.isLinux = platform === 'linux';\n  exports.isIBMi = os.type() === 'OS400';\n})(constants);\nconst fs$2 = require$$0$1;\nconst sysPath$2 = require$$0$2;\nconst {\n  promisify: promisify$2\n} = require$$2;\nconst isBinaryPath = isBinaryPath$1;\nconst {\n  isWindows: isWindows$1,\n  isLinux,\n  EMPTY_FN: EMPTY_FN$2,\n  EMPTY_STR: EMPTY_STR$1,\n  KEY_LISTENERS,\n  KEY_ERR,\n  KEY_RAW,\n  HANDLER_KEYS,\n  EV_CHANGE: EV_CHANGE$2,\n  EV_ADD: EV_ADD$2,\n  EV_ADD_DIR: EV_ADD_DIR$2,\n  EV_ERROR: EV_ERROR$2,\n  STR_DATA: STR_DATA$1,\n  STR_END: STR_END$2,\n  BRACE_START: BRACE_START$1,\n  STAR\n} = constants;\nconst THROTTLE_MODE_WATCH = 'watch';\nconst open = promisify$2(fs$2.open);\nconst stat$2 = promisify$2(fs$2.stat);\nconst lstat$1 = promisify$2(fs$2.lstat);\nconst close = promisify$2(fs$2.close);\nconst fsrealpath = promisify$2(fs$2.realpath);\nconst statMethods$1 = {\n  lstat: lstat$1,\n  stat: stat$2\n};\n\n// TODO: emit errors properly. Example: EMFILE on Macos.\nconst foreach = (val, fn) => {\n  if (val instanceof Set) {\n    val.forEach(fn);\n  } else {\n    fn(val);\n  }\n};\nconst addAndConvert = (main, prop, item) => {\n  let container = main[prop];\n  if (!(container instanceof Set)) {\n    main[prop] = container = new Set([container]);\n  }\n  container.add(item);\n};\nconst clearItem = cont => key => {\n  const set = cont[key];\n  if (set instanceof Set) {\n    set.clear();\n  } else {\n    delete cont[key];\n  }\n};\nconst delFromSet = (main, prop, item) => {\n  const container = main[prop];\n  if (container instanceof Set) {\n    container.delete(item);\n  } else if (container === item) {\n    delete main[prop];\n  }\n};\nconst isEmptySet = val => val instanceof Set ? val.size === 0 : !val;\n\n/**\n * @typedef {String} Path\n */\n\n// fs_watch helpers\n\n// object to hold per-process fs_watch instances\n// (may be shared across chokidar FSWatcher instances)\n\n/**\n * @typedef {Object} FsWatchContainer\n * @property {Set} listeners\n * @property {Set} errHandlers\n * @property {Set} rawEmitters\n * @property {fs.FSWatcher=} watcher\n * @property {Boolean=} watcherUnusable\n */\n\n/**\n * @type {Map<String,FsWatchContainer>}\n */\nconst FsWatchInstances = new Map();\n\n/**\n * Instantiates the fs_watch interface\n * @param {String} path to be watched\n * @param {Object} options to be passed to fs_watch\n * @param {Function} listener main event handler\n * @param {Function} errHandler emits info about errors\n * @param {Function} emitRaw emits raw event data\n * @returns {fs.FSWatcher} new fsevents instance\n */\nfunction createFsWatchInstance(path, options, listener, errHandler, emitRaw) {\n  const handleEvent = (rawEvent, evPath) => {\n    listener(path);\n    emitRaw(rawEvent, evPath, {\n      watchedPath: path\n    });\n\n    // emit based on events occurring for files from a directory's watcher in\n    // case the file's watcher misses it (and rely on throttling to de-dupe)\n    if (evPath && path !== evPath) {\n      fsWatchBroadcast(sysPath$2.resolve(path, evPath), KEY_LISTENERS, sysPath$2.join(path, evPath));\n    }\n  };\n  try {\n    return fs$2.watch(path, options, handleEvent);\n  } catch (error) {\n    errHandler(error);\n  }\n}\n\n/**\n * Helper for passing fs_watch event data to a collection of listeners\n * @param {Path} fullPath absolute path bound to fs_watch instance\n * @param {String} type listener type\n * @param {*=} val1 arguments to be passed to listeners\n * @param {*=} val2\n * @param {*=} val3\n */\nconst fsWatchBroadcast = (fullPath, type, val1, val2, val3) => {\n  const cont = FsWatchInstances.get(fullPath);\n  if (!cont) return;\n  foreach(cont[type], listener => {\n    listener(val1, val2, val3);\n  });\n};\n\n/**\n * Instantiates the fs_watch interface or binds listeners\n * to an existing one covering the same file system entry\n * @param {String} path\n * @param {String} fullPath absolute path\n * @param {Object} options to be passed to fs_watch\n * @param {Object} handlers container for event listener functions\n */\nconst setFsWatchListener = (path, fullPath, options, handlers) => {\n  const {\n    listener,\n    errHandler,\n    rawEmitter\n  } = handlers;\n  let cont = FsWatchInstances.get(fullPath);\n\n  /** @type {fs.FSWatcher=} */\n  let watcher;\n  if (!options.persistent) {\n    watcher = createFsWatchInstance(path, options, listener, errHandler, rawEmitter);\n    return watcher.close.bind(watcher);\n  }\n  if (cont) {\n    addAndConvert(cont, KEY_LISTENERS, listener);\n    addAndConvert(cont, KEY_ERR, errHandler);\n    addAndConvert(cont, KEY_RAW, rawEmitter);\n  } else {\n    watcher = createFsWatchInstance(path, options, fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS), errHandler,\n    // no need to use broadcast here\n    fsWatchBroadcast.bind(null, fullPath, KEY_RAW));\n    if (!watcher) return;\n    watcher.on(EV_ERROR$2, async error => {\n      const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);\n      cont.watcherUnusable = true; // documented since Node 10.4.1\n      // Workaround for https://github.com/joyent/node/issues/4337\n      if (isWindows$1 && error.code === 'EPERM') {\n        try {\n          const fd = await open(path, 'r');\n          await close(fd);\n          broadcastErr(error);\n        } catch (err) {}\n      } else {\n        broadcastErr(error);\n      }\n    });\n    cont = {\n      listeners: listener,\n      errHandlers: errHandler,\n      rawEmitters: rawEmitter,\n      watcher\n    };\n    FsWatchInstances.set(fullPath, cont);\n  }\n  // const index = cont.listeners.indexOf(listener);\n\n  // removes this instance's listeners and closes the underlying fs_watch\n  // instance if there are no more listeners left\n  return () => {\n    delFromSet(cont, KEY_LISTENERS, listener);\n    delFromSet(cont, KEY_ERR, errHandler);\n    delFromSet(cont, KEY_RAW, rawEmitter);\n    if (isEmptySet(cont.listeners)) {\n      // Check to protect against issue gh-730.\n      // if (cont.watcherUnusable) {\n      cont.watcher.close();\n      // }\n      FsWatchInstances.delete(fullPath);\n      HANDLER_KEYS.forEach(clearItem(cont));\n      cont.watcher = undefined;\n      Object.freeze(cont);\n    }\n  };\n};\n\n// fs_watchFile helpers\n\n// object to hold per-process fs_watchFile instances\n// (may be shared across chokidar FSWatcher instances)\nconst FsWatchFileInstances = new Map();\n\n/**\n * Instantiates the fs_watchFile interface or binds listeners\n * to an existing one covering the same file system entry\n * @param {String} path to be watched\n * @param {String} fullPath absolute path\n * @param {Object} options options to be passed to fs_watchFile\n * @param {Object} handlers container for event listener functions\n * @returns {Function} closer\n */\nconst setFsWatchFileListener = (path, fullPath, options, handlers) => {\n  const {\n    listener,\n    rawEmitter\n  } = handlers;\n  let cont = FsWatchFileInstances.get(fullPath);\n  const copts = cont && cont.options;\n  if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {\n    fs$2.unwatchFile(fullPath);\n    cont = undefined;\n  }\n\n  /* eslint-enable no-unused-vars, prefer-destructuring */\n\n  if (cont) {\n    addAndConvert(cont, KEY_LISTENERS, listener);\n    addAndConvert(cont, KEY_RAW, rawEmitter);\n  } else {\n    // TODO\n    // listeners.add(listener);\n    // rawEmitters.add(rawEmitter);\n    cont = {\n      listeners: listener,\n      rawEmitters: rawEmitter,\n      options,\n      watcher: fs$2.watchFile(fullPath, options, (curr, prev) => {\n        foreach(cont.rawEmitters, rawEmitter => {\n          rawEmitter(EV_CHANGE$2, fullPath, {\n            curr,\n            prev\n          });\n        });\n        const currmtime = curr.mtimeMs;\n        if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {\n          foreach(cont.listeners, listener => listener(path, curr));\n        }\n      })\n    };\n    FsWatchFileInstances.set(fullPath, cont);\n  }\n  // const index = cont.listeners.indexOf(listener);\n\n  // Removes this instance's listeners and closes the underlying fs_watchFile\n  // instance if there are no more listeners left.\n  return () => {\n    delFromSet(cont, KEY_LISTENERS, listener);\n    delFromSet(cont, KEY_RAW, rawEmitter);\n    if (isEmptySet(cont.listeners)) {\n      FsWatchFileInstances.delete(fullPath);\n      fs$2.unwatchFile(fullPath);\n      cont.options = cont.watcher = undefined;\n      Object.freeze(cont);\n    }\n  };\n};\n\n/**\n * @mixin\n */\nlet NodeFsHandler$1 = class NodeFsHandler {\n  /**\n   * @param {import(\"../index\").FSWatcher} fsW\n   */\n  constructor(fsW) {\n    this.fsw = fsW;\n    this._boundHandleError = error => fsW._handleError(error);\n  }\n\n  /**\n   * Watch file for changes with fs_watchFile or fs_watch.\n   * @param {String} path to file or dir\n   * @param {Function} listener on fs change\n   * @returns {Function} closer for the watcher instance\n   */\n  _watchWithNodeFs(path, listener) {\n    const opts = this.fsw.options;\n    const directory = sysPath$2.dirname(path);\n    const basename = sysPath$2.basename(path);\n    const parent = this.fsw._getWatchedDir(directory);\n    parent.add(basename);\n    const absolutePath = sysPath$2.resolve(path);\n    const options = {\n      persistent: opts.persistent\n    };\n    if (!listener) listener = EMPTY_FN$2;\n    let closer;\n    if (opts.usePolling) {\n      options.interval = opts.enableBinaryInterval && isBinaryPath(basename) ? opts.binaryInterval : opts.interval;\n      closer = setFsWatchFileListener(path, absolutePath, options, {\n        listener,\n        rawEmitter: this.fsw._emitRaw\n      });\n    } else {\n      closer = setFsWatchListener(path, absolutePath, options, {\n        listener,\n        errHandler: this._boundHandleError,\n        rawEmitter: this.fsw._emitRaw\n      });\n    }\n    return closer;\n  }\n\n  /**\n   * Watch a file and emit add event if warranted.\n   * @param {Path} file Path\n   * @param {fs.Stats} stats result of fs_stat\n   * @param {Boolean} initialAdd was the file added at watch instantiation?\n   * @returns {Function} closer for the watcher instance\n   */\n  _handleFile(file, stats, initialAdd) {\n    if (this.fsw.closed) {\n      return;\n    }\n    const dirname = sysPath$2.dirname(file);\n    const basename = sysPath$2.basename(file);\n    const parent = this.fsw._getWatchedDir(dirname);\n    // stats is always present\n    let prevStats = stats;\n\n    // if the file is already being watched, do nothing\n    if (parent.has(basename)) return;\n    const listener = async (path, newStats) => {\n      if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5)) return;\n      if (!newStats || newStats.mtimeMs === 0) {\n        try {\n          const newStats = await stat$2(file);\n          if (this.fsw.closed) return;\n          // Check that change event was not fired because of changed only accessTime.\n          const at = newStats.atimeMs;\n          const mt = newStats.mtimeMs;\n          if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n            this.fsw._emit(EV_CHANGE$2, file, newStats);\n          }\n          if (isLinux && prevStats.ino !== newStats.ino) {\n            this.fsw._closeFile(path);\n            prevStats = newStats;\n            this.fsw._addPathCloser(path, this._watchWithNodeFs(file, listener));\n          } else {\n            prevStats = newStats;\n          }\n        } catch (error) {\n          // Fix issues where mtime is null but file is still present\n          this.fsw._remove(dirname, basename);\n        }\n        // add is about to be emitted if file not already tracked in parent\n      } else if (parent.has(basename)) {\n        // Check that change event was not fired because of changed only accessTime.\n        const at = newStats.atimeMs;\n        const mt = newStats.mtimeMs;\n        if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n          this.fsw._emit(EV_CHANGE$2, file, newStats);\n        }\n        prevStats = newStats;\n      }\n    };\n    // kick off the watcher\n    const closer = this._watchWithNodeFs(file, listener);\n\n    // emit an add event if we're supposed to\n    if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {\n      if (!this.fsw._throttle(EV_ADD$2, file, 0)) return;\n      this.fsw._emit(EV_ADD$2, file, stats);\n    }\n    return closer;\n  }\n\n  /**\n   * Handle symlinks encountered while reading a dir.\n   * @param {Object} entry returned by readdirp\n   * @param {String} directory path of dir being read\n   * @param {String} path of this item\n   * @param {String} item basename of this item\n   * @returns {Promise<Boolean>} true if no more processing is needed for this entry.\n   */\n  async _handleSymlink(entry, directory, path, item) {\n    if (this.fsw.closed) {\n      return;\n    }\n    const full = entry.fullPath;\n    const dir = this.fsw._getWatchedDir(directory);\n    if (!this.fsw.options.followSymlinks) {\n      // watch symlink directly (don't follow) and detect changes\n      this.fsw._incrReadyCount();\n      let linkPath;\n      try {\n        linkPath = await fsrealpath(path);\n      } catch (e) {\n        this.fsw._emitReady();\n        return true;\n      }\n      if (this.fsw.closed) return;\n      if (dir.has(item)) {\n        if (this.fsw._symlinkPaths.get(full) !== linkPath) {\n          this.fsw._symlinkPaths.set(full, linkPath);\n          this.fsw._emit(EV_CHANGE$2, path, entry.stats);\n        }\n      } else {\n        dir.add(item);\n        this.fsw._symlinkPaths.set(full, linkPath);\n        this.fsw._emit(EV_ADD$2, path, entry.stats);\n      }\n      this.fsw._emitReady();\n      return true;\n    }\n\n    // don't follow the same symlink more than once\n    if (this.fsw._symlinkPaths.has(full)) {\n      return true;\n    }\n    this.fsw._symlinkPaths.set(full, true);\n  }\n  _handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {\n    // Normalize the directory name on Windows\n    directory = sysPath$2.join(directory, EMPTY_STR$1);\n    if (!wh.hasGlob) {\n      throttler = this.fsw._throttle('readdir', directory, 1000);\n      if (!throttler) return;\n    }\n    const previous = this.fsw._getWatchedDir(wh.path);\n    const current = new Set();\n    let stream = this.fsw._readdirp(directory, {\n      fileFilter: entry => wh.filterPath(entry),\n      directoryFilter: entry => wh.filterDir(entry),\n      depth: 0\n    }).on(STR_DATA$1, async entry => {\n      if (this.fsw.closed) {\n        stream = undefined;\n        return;\n      }\n      const item = entry.path;\n      let path = sysPath$2.join(directory, item);\n      current.add(item);\n      if (entry.stats.isSymbolicLink() && (await this._handleSymlink(entry, directory, path, item))) {\n        return;\n      }\n      if (this.fsw.closed) {\n        stream = undefined;\n        return;\n      }\n      // Files that present in current directory snapshot\n      // but absent in previous are added to watch list and\n      // emit `add` event.\n      if (item === target || !target && !previous.has(item)) {\n        this.fsw._incrReadyCount();\n\n        // ensure relativeness of path is preserved in case of watcher reuse\n        path = sysPath$2.join(dir, sysPath$2.relative(dir, path));\n        this._addToNodeFs(path, initialAdd, wh, depth + 1);\n      }\n    }).on(EV_ERROR$2, this._boundHandleError);\n    return new Promise(resolve => stream.once(STR_END$2, () => {\n      if (this.fsw.closed) {\n        stream = undefined;\n        return;\n      }\n      const wasThrottled = throttler ? throttler.clear() : false;\n      resolve();\n\n      // Files that absent in current directory snapshot\n      // but present in previous emit `remove` event\n      // and are removed from @watched[directory].\n      previous.getChildren().filter(item => {\n        return item !== directory && !current.has(item) && (\n        // in case of intersecting globs;\n        // a path may have been filtered out of this readdir, but\n        // shouldn't be removed because it matches a different glob\n        !wh.hasGlob || wh.filterPath({\n          fullPath: sysPath$2.resolve(directory, item)\n        }));\n      }).forEach(item => {\n        this.fsw._remove(directory, item);\n      });\n      stream = undefined;\n\n      // one more time for any missed in case changes came in extremely quickly\n      if (wasThrottled) this._handleRead(directory, false, wh, target, dir, depth, throttler);\n    }));\n  }\n\n  /**\n   * Read directory to add / remove files from `@watched` list and re-read it on change.\n   * @param {String} dir fs path\n   * @param {fs.Stats} stats\n   * @param {Boolean} initialAdd\n   * @param {Number} depth relative to user-supplied path\n   * @param {String} target child path targeted for watch\n   * @param {Object} wh Common watch helpers for this path\n   * @param {String} realpath\n   * @returns {Promise<Function>} closer for the watcher instance.\n   */\n  async _handleDir(dir, stats, initialAdd, depth, target, wh, realpath) {\n    const parentDir = this.fsw._getWatchedDir(sysPath$2.dirname(dir));\n    const tracked = parentDir.has(sysPath$2.basename(dir));\n    if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {\n      if (!wh.hasGlob || wh.globFilter(dir)) this.fsw._emit(EV_ADD_DIR$2, dir, stats);\n    }\n\n    // ensure dir is tracked (harmless if redundant)\n    parentDir.add(sysPath$2.basename(dir));\n    this.fsw._getWatchedDir(dir);\n    let throttler;\n    let closer;\n    const oDepth = this.fsw.options.depth;\n    if ((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath)) {\n      if (!target) {\n        await this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);\n        if (this.fsw.closed) return;\n      }\n      closer = this._watchWithNodeFs(dir, (dirPath, stats) => {\n        // if current directory is removed, do nothing\n        if (stats && stats.mtimeMs === 0) return;\n        this._handleRead(dirPath, false, wh, target, dir, depth, throttler);\n      });\n    }\n    return closer;\n  }\n\n  /**\n   * Handle added file, directory, or glob pattern.\n   * Delegates call to _handleFile / _handleDir after checks.\n   * @param {String} path to file or ir\n   * @param {Boolean} initialAdd was the file added at watch instantiation?\n   * @param {Object} priorWh depth relative to user-supplied path\n   * @param {Number} depth Child path actually targeted for watch\n   * @param {String=} target Child path actually targeted for watch\n   * @returns {Promise}\n   */\n  async _addToNodeFs(path, initialAdd, priorWh, depth, target) {\n    const ready = this.fsw._emitReady;\n    if (this.fsw._isIgnored(path) || this.fsw.closed) {\n      ready();\n      return false;\n    }\n    const wh = this.fsw._getWatchHelpers(path, depth);\n    if (!wh.hasGlob && priorWh) {\n      wh.hasGlob = priorWh.hasGlob;\n      wh.globFilter = priorWh.globFilter;\n      wh.filterPath = entry => priorWh.filterPath(entry);\n      wh.filterDir = entry => priorWh.filterDir(entry);\n    }\n\n    // evaluate what is at the path we're being asked to watch\n    try {\n      const stats = await statMethods$1[wh.statMethod](wh.watchPath);\n      if (this.fsw.closed) return;\n      if (this.fsw._isIgnored(wh.watchPath, stats)) {\n        ready();\n        return false;\n      }\n      const follow = this.fsw.options.followSymlinks && !path.includes(STAR) && !path.includes(BRACE_START$1);\n      let closer;\n      if (stats.isDirectory()) {\n        const absPath = sysPath$2.resolve(path);\n        const targetPath = follow ? await fsrealpath(path) : path;\n        if (this.fsw.closed) return;\n        closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);\n        if (this.fsw.closed) return;\n        // preserve this symlink's target path\n        if (absPath !== targetPath && targetPath !== undefined) {\n          this.fsw._symlinkPaths.set(absPath, targetPath);\n        }\n      } else if (stats.isSymbolicLink()) {\n        const targetPath = follow ? await fsrealpath(path) : path;\n        if (this.fsw.closed) return;\n        const parent = sysPath$2.dirname(wh.watchPath);\n        this.fsw._getWatchedDir(parent).add(wh.watchPath);\n        this.fsw._emit(EV_ADD$2, wh.watchPath, stats);\n        closer = await this._handleDir(parent, stats, initialAdd, depth, path, wh, targetPath);\n        if (this.fsw.closed) return;\n\n        // preserve this symlink's target path\n        if (targetPath !== undefined) {\n          this.fsw._symlinkPaths.set(sysPath$2.resolve(path), targetPath);\n        }\n      } else {\n        closer = this._handleFile(wh.watchPath, stats, initialAdd);\n      }\n      ready();\n      this.fsw._addPathCloser(path, closer);\n      return false;\n    } catch (error) {\n      if (this.fsw._handleError(error)) {\n        ready();\n        return path;\n      }\n    }\n  }\n};\nvar nodefsHandler = NodeFsHandler$1;\nvar fseventsHandlerExports = {};\nvar fseventsHandler = {\n  get exports() {\n    return fseventsHandlerExports;\n  },\n  set exports(v) {\n    fseventsHandlerExports = v;\n  }\n};\nconst require$$3 = /*@__PURE__*/getAugmentedNamespace(fseventsImporter);\nconst fs$1 = require$$0$1;\nconst sysPath$1 = require$$0$2;\nconst {\n  promisify: promisify$1\n} = require$$2;\nlet fsevents;\ntry {\n  fsevents = require$$3.getFsEvents();\n} catch (error) {\n  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error);\n}\nif (fsevents) {\n  // TODO: real check\n  const mtch = process.version.match(/v(\\d+)\\.(\\d+)/);\n  if (mtch && mtch[1] && mtch[2]) {\n    const maj = Number.parseInt(mtch[1], 10);\n    const min = Number.parseInt(mtch[2], 10);\n    if (maj === 8 && min < 16) {\n      fsevents = undefined;\n    }\n  }\n}\nconst {\n  EV_ADD: EV_ADD$1,\n  EV_CHANGE: EV_CHANGE$1,\n  EV_ADD_DIR: EV_ADD_DIR$1,\n  EV_UNLINK: EV_UNLINK$1,\n  EV_ERROR: EV_ERROR$1,\n  STR_DATA,\n  STR_END: STR_END$1,\n  FSEVENT_CREATED,\n  FSEVENT_MODIFIED,\n  FSEVENT_DELETED,\n  FSEVENT_MOVED,\n  // FSEVENT_CLONED,\n  FSEVENT_UNKNOWN,\n  FSEVENT_TYPE_FILE,\n  FSEVENT_TYPE_DIRECTORY,\n  FSEVENT_TYPE_SYMLINK,\n  ROOT_GLOBSTAR,\n  DIR_SUFFIX,\n  DOT_SLASH,\n  FUNCTION_TYPE: FUNCTION_TYPE$1,\n  EMPTY_FN: EMPTY_FN$1,\n  IDENTITY_FN\n} = constants;\nconst Depth = value => isNaN(value) ? {} : {\n  depth: value\n};\nconst stat$1 = promisify$1(fs$1.stat);\nconst lstat = promisify$1(fs$1.lstat);\nconst realpath = promisify$1(fs$1.realpath);\nconst statMethods = {\n  stat: stat$1,\n  lstat\n};\n\n/**\n * @typedef {String} Path\n */\n\n/**\n * @typedef {Object} FsEventsWatchContainer\n * @property {Set<Function>} listeners\n * @property {Function} rawEmitter\n * @property {{stop: Function}} watcher\n */\n\n// fsevents instance helper functions\n/**\n * Object to hold per-process fsevents instances (may be shared across chokidar FSWatcher instances)\n * @type {Map<Path,FsEventsWatchContainer>}\n */\nconst FSEventsWatchers = new Map();\n\n// Threshold of duplicate path prefixes at which to start\n// consolidating going forward\nconst consolidateThreshhold = 10;\nconst wrongEventFlags = new Set([69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912]);\n\n/**\n * Instantiates the fsevents interface\n * @param {Path} path path to be watched\n * @param {Function} callback called when fsevents is bound and ready\n * @returns {{stop: Function}} new fsevents instance\n */\nconst createFSEventsInstance = (path, callback) => {\n  const stop = fsevents.watch(path, callback);\n  return {\n    stop\n  };\n};\n\n/**\n * Instantiates the fsevents interface or binds listeners to an existing one covering\n * the same file tree.\n * @param {Path} path           - to be watched\n * @param {Path} realPath       - real path for symlinks\n * @param {Function} listener   - called when fsevents emits events\n * @param {Function} rawEmitter - passes data to listeners of the 'raw' event\n * @returns {Function} closer\n */\nfunction setFSEventsListener(path, realPath, listener, rawEmitter) {\n  let watchPath = sysPath$1.extname(realPath) ? sysPath$1.dirname(realPath) : realPath;\n  const parentPath = sysPath$1.dirname(watchPath);\n  let cont = FSEventsWatchers.get(watchPath);\n\n  // If we've accumulated a substantial number of paths that\n  // could have been consolidated by watching one directory\n  // above the current one, create a watcher on the parent\n  // path instead, so that we do consolidate going forward.\n  if (couldConsolidate(parentPath)) {\n    watchPath = parentPath;\n  }\n  const resolvedPath = sysPath$1.resolve(path);\n  const hasSymlink = resolvedPath !== realPath;\n  const filteredListener = (fullPath, flags, info) => {\n    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);\n    if (fullPath === resolvedPath || !fullPath.indexOf(resolvedPath + sysPath$1.sep)) listener(fullPath, flags, info);\n  };\n\n  // check if there is already a watcher on a parent path\n  // modifies `watchPath` to the parent path when it finds a match\n  let watchedParent = false;\n  for (const watchedPath of FSEventsWatchers.keys()) {\n    if (realPath.indexOf(sysPath$1.resolve(watchedPath) + sysPath$1.sep) === 0) {\n      watchPath = watchedPath;\n      cont = FSEventsWatchers.get(watchPath);\n      watchedParent = true;\n      break;\n    }\n  }\n  if (cont || watchedParent) {\n    cont.listeners.add(filteredListener);\n  } else {\n    cont = {\n      listeners: new Set([filteredListener]),\n      rawEmitter,\n      watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {\n        if (!cont.listeners.size) return;\n        const info = fsevents.getInfo(fullPath, flags);\n        cont.listeners.forEach(list => {\n          list(fullPath, flags, info);\n        });\n        cont.rawEmitter(info.event, fullPath, info);\n      })\n    };\n    FSEventsWatchers.set(watchPath, cont);\n  }\n\n  // removes this instance's listeners and closes the underlying fsevents\n  // instance if there are no more listeners left\n  return () => {\n    const lst = cont.listeners;\n    lst.delete(filteredListener);\n    if (!lst.size) {\n      FSEventsWatchers.delete(watchPath);\n      if (cont.watcher) return cont.watcher.stop().then(() => {\n        cont.rawEmitter = cont.watcher = undefined;\n        Object.freeze(cont);\n      });\n    }\n  };\n}\n\n// Decide whether or not we should start a new higher-level\n// parent watcher\nconst couldConsolidate = path => {\n  let count = 0;\n  for (const watchPath of FSEventsWatchers.keys()) {\n    if (watchPath.indexOf(path) === 0) {\n      count++;\n      if (count >= consolidateThreshhold) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n// returns boolean indicating whether fsevents can be used\nconst canUse = () => fsevents && FSEventsWatchers.size < 128;\n\n// determines subdirectory traversal levels from root to path\nconst calcDepth = (path, root) => {\n  let i = 0;\n  while (!path.indexOf(root) && (path = sysPath$1.dirname(path)) !== root) i++;\n  return i;\n};\n\n// returns boolean indicating whether the fsevents' event info has the same type\n// as the one returned by fs.stat\nconst sameTypes = (info, stats) => info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() || info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() || info.type === FSEVENT_TYPE_FILE && stats.isFile();\n\n/**\n * @mixin\n */\nlet FsEventsHandler$1 = class FsEventsHandler {\n  /**\n   * @param {import('../index').FSWatcher} fsw\n   */\n  constructor(fsw) {\n    this.fsw = fsw;\n  }\n  checkIgnored(path, stats) {\n    const ipaths = this.fsw._ignoredPaths;\n    if (this.fsw._isIgnored(path, stats)) {\n      ipaths.add(path);\n      if (stats && stats.isDirectory()) {\n        ipaths.add(path + ROOT_GLOBSTAR);\n      }\n      return true;\n    }\n    ipaths.delete(path);\n    ipaths.delete(path + ROOT_GLOBSTAR);\n  }\n  addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n    const event = watchedDir.has(item) ? EV_CHANGE$1 : EV_ADD$1;\n    this.handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n  }\n  async checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n    try {\n      const stats = await stat$1(path);\n      if (this.fsw.closed) return;\n      if (sameTypes(info, stats)) {\n        this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      } else {\n        this.handleEvent(EV_UNLINK$1, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      }\n    } catch (error) {\n      if (error.code === 'EACCES') {\n        this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      } else {\n        this.handleEvent(EV_UNLINK$1, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      }\n    }\n  }\n  handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n    if (this.fsw.closed || this.checkIgnored(path)) return;\n    if (event === EV_UNLINK$1) {\n      const isDirectory = info.type === FSEVENT_TYPE_DIRECTORY;\n      // suppress unlink events on never before seen files\n      if (isDirectory || watchedDir.has(item)) {\n        this.fsw._remove(parent, item, isDirectory);\n      }\n    } else {\n      if (event === EV_ADD$1) {\n        // track new directories\n        if (info.type === FSEVENT_TYPE_DIRECTORY) this.fsw._getWatchedDir(path);\n        if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {\n          // push symlinks back to the top of the stack to get handled\n          const curDepth = opts.depth === undefined ? undefined : calcDepth(fullPath, realPath) + 1;\n          return this._addToFsEvents(path, false, true, curDepth);\n        }\n\n        // track new paths\n        // (other than symlinks being followed, which will be tracked soon)\n        this.fsw._getWatchedDir(parent).add(item);\n      }\n      /**\n       * @type {'add'|'addDir'|'unlink'|'unlinkDir'}\n       */\n      const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;\n      this.fsw._emit(eventName, path);\n      if (eventName === EV_ADD_DIR$1) this._addToFsEvents(path, false, true);\n    }\n  }\n\n  /**\n   * Handle symlinks encountered during directory scan\n   * @param {String} watchPath  - file/dir path to be watched with fsevents\n   * @param {String} realPath   - real path (in case of symlinks)\n   * @param {Function} transform  - path transformer\n   * @param {Function} globFilter - path filter in case a glob pattern was provided\n   * @returns {Function} closer for the watcher instance\n  */\n  _watchWithFsEvents(watchPath, realPath, transform, globFilter) {\n    if (this.fsw.closed || this.fsw._isIgnored(watchPath)) return;\n    const opts = this.fsw.options;\n    const watchCallback = async (fullPath, flags, info) => {\n      if (this.fsw.closed) return;\n      if (opts.depth !== undefined && calcDepth(fullPath, realPath) > opts.depth) return;\n      const path = transform(sysPath$1.join(watchPath, sysPath$1.relative(watchPath, fullPath)));\n      if (globFilter && !globFilter(path)) return;\n      // ensure directories are tracked\n      const parent = sysPath$1.dirname(path);\n      const item = sysPath$1.basename(path);\n      const watchedDir = this.fsw._getWatchedDir(info.type === FSEVENT_TYPE_DIRECTORY ? path : parent);\n\n      // correct for wrong events emitted\n      if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {\n        if (typeof opts.ignored === FUNCTION_TYPE$1) {\n          let stats;\n          try {\n            stats = await stat$1(path);\n          } catch (error) {}\n          if (this.fsw.closed) return;\n          if (this.checkIgnored(path, stats)) return;\n          if (sameTypes(info, stats)) {\n            this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n          } else {\n            this.handleEvent(EV_UNLINK$1, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n          }\n        } else {\n          this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        }\n      } else {\n        switch (info.event) {\n          case FSEVENT_CREATED:\n          case FSEVENT_MODIFIED:\n            return this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n          case FSEVENT_DELETED:\n          case FSEVENT_MOVED:\n            return this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        }\n      }\n    };\n    const closer = setFSEventsListener(watchPath, realPath, watchCallback, this.fsw._emitRaw);\n    this.fsw._emitReady();\n    return closer;\n  }\n\n  /**\n   * Handle symlinks encountered during directory scan\n   * @param {String} linkPath path to symlink\n   * @param {String} fullPath absolute path to the symlink\n   * @param {Function} transform pre-existing path transformer\n   * @param {Number} curDepth level of subdirectories traversed to where symlink is\n   * @returns {Promise<void>}\n   */\n  async _handleFsEventsSymlink(linkPath, fullPath, transform, curDepth) {\n    // don't follow the same symlink more than once\n    if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath)) return;\n    this.fsw._symlinkPaths.set(fullPath, true);\n    this.fsw._incrReadyCount();\n    try {\n      const linkTarget = await realpath(linkPath);\n      if (this.fsw.closed) return;\n      if (this.fsw._isIgnored(linkTarget)) {\n        return this.fsw._emitReady();\n      }\n      this.fsw._incrReadyCount();\n\n      // add the linkTarget for watching with a wrapper for transform\n      // that causes emitted paths to incorporate the link's path\n      this._addToFsEvents(linkTarget || linkPath, path => {\n        let aliasedPath = linkPath;\n        if (linkTarget && linkTarget !== DOT_SLASH) {\n          aliasedPath = path.replace(linkTarget, linkPath);\n        } else if (path !== DOT_SLASH) {\n          aliasedPath = sysPath$1.join(linkPath, path);\n        }\n        return transform(aliasedPath);\n      }, false, curDepth);\n    } catch (error) {\n      if (this.fsw._handleError(error)) {\n        return this.fsw._emitReady();\n      }\n    }\n  }\n\n  /**\n   *\n   * @param {Path} newPath\n   * @param {fs.Stats} stats\n   */\n  emitAdd(newPath, stats, processPath, opts, forceAdd) {\n    const pp = processPath(newPath);\n    const isDir = stats.isDirectory();\n    const dirObj = this.fsw._getWatchedDir(sysPath$1.dirname(pp));\n    const base = sysPath$1.basename(pp);\n\n    // ensure empty dirs get tracked\n    if (isDir) this.fsw._getWatchedDir(pp);\n    if (dirObj.has(base)) return;\n    dirObj.add(base);\n    if (!opts.ignoreInitial || forceAdd === true) {\n      this.fsw._emit(isDir ? EV_ADD_DIR$1 : EV_ADD$1, pp, stats);\n    }\n  }\n  initWatch(realPath, path, wh, processPath) {\n    if (this.fsw.closed) return;\n    const closer = this._watchWithFsEvents(wh.watchPath, sysPath$1.resolve(realPath || wh.watchPath), processPath, wh.globFilter);\n    this.fsw._addPathCloser(path, closer);\n  }\n\n  /**\n   * Handle added path with fsevents\n   * @param {String} path file/dir path or glob pattern\n   * @param {Function|Boolean=} transform converts working path to what the user expects\n   * @param {Boolean=} forceAdd ensure add is emitted\n   * @param {Number=} priorDepth Level of subdirectories already traversed.\n   * @returns {Promise<void>}\n   */\n  async _addToFsEvents(path, transform, forceAdd, priorDepth) {\n    if (this.fsw.closed) {\n      return;\n    }\n    const opts = this.fsw.options;\n    const processPath = typeof transform === FUNCTION_TYPE$1 ? transform : IDENTITY_FN;\n    const wh = this.fsw._getWatchHelpers(path);\n\n    // evaluate what is at the path we're being asked to watch\n    try {\n      const stats = await statMethods[wh.statMethod](wh.watchPath);\n      if (this.fsw.closed) return;\n      if (this.fsw._isIgnored(wh.watchPath, stats)) {\n        throw null;\n      }\n      if (stats.isDirectory()) {\n        // emit addDir unless this is a glob parent\n        if (!wh.globFilter) this.emitAdd(processPath(path), stats, processPath, opts, forceAdd);\n\n        // don't recurse further if it would exceed depth setting\n        if (priorDepth && priorDepth > opts.depth) return;\n\n        // scan the contents of the dir\n        this.fsw._readdirp(wh.watchPath, {\n          fileFilter: entry => wh.filterPath(entry),\n          directoryFilter: entry => wh.filterDir(entry),\n          ...Depth(opts.depth - (priorDepth || 0))\n        }).on(STR_DATA, entry => {\n          // need to check filterPath on dirs b/c filterDir is less restrictive\n          if (this.fsw.closed) {\n            return;\n          }\n          if (entry.stats.isDirectory() && !wh.filterPath(entry)) return;\n          const joinedPath = sysPath$1.join(wh.watchPath, entry.path);\n          const {\n            fullPath\n          } = entry;\n          if (wh.followSymlinks && entry.stats.isSymbolicLink()) {\n            // preserve the current depth here since it can't be derived from\n            // real paths past the symlink\n            const curDepth = opts.depth === undefined ? undefined : calcDepth(joinedPath, sysPath$1.resolve(wh.watchPath)) + 1;\n            this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);\n          } else {\n            this.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);\n          }\n        }).on(EV_ERROR$1, EMPTY_FN$1).on(STR_END$1, () => {\n          this.fsw._emitReady();\n        });\n      } else {\n        this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);\n        this.fsw._emitReady();\n      }\n    } catch (error) {\n      if (!error || this.fsw._handleError(error)) {\n        // TODO: Strange thing: \"should not choke on an ignored watch path\" will be failed without 2 ready calls -__-\n        this.fsw._emitReady();\n        this.fsw._emitReady();\n      }\n    }\n    if (opts.persistent && forceAdd !== true) {\n      if (typeof transform === FUNCTION_TYPE$1) {\n        // realpath has already been resolved\n        this.initWatch(undefined, path, wh, processPath);\n      } else {\n        let realPath;\n        try {\n          realPath = await realpath(wh.watchPath);\n        } catch (e) {}\n        this.initWatch(realPath, path, wh, processPath);\n      }\n    }\n  }\n};\nfseventsHandler.exports = FsEventsHandler$1;\nfseventsHandlerExports.canUse = canUse;\nconst {\n  EventEmitter\n} = require$$0$3;\nconst fs = require$$0$1;\nconst sysPath = require$$0$2;\nconst {\n  promisify\n} = require$$2;\nconst readdirp = readdirp_1;\nconst anymatch = anymatchExports.default;\nconst globParent = globParent$1;\nconst isGlob = isGlob$2;\nconst braces = braces_1;\nconst normalizePath = normalizePath$2;\nconst NodeFsHandler = nodefsHandler;\nconst FsEventsHandler = fseventsHandlerExports;\nconst {\n  EV_ALL,\n  EV_READY,\n  EV_ADD,\n  EV_CHANGE,\n  EV_UNLINK,\n  EV_ADD_DIR,\n  EV_UNLINK_DIR,\n  EV_RAW,\n  EV_ERROR,\n  STR_CLOSE,\n  STR_END,\n  BACK_SLASH_RE,\n  DOUBLE_SLASH_RE,\n  SLASH_OR_BACK_SLASH_RE,\n  DOT_RE,\n  REPLACER_RE,\n  SLASH,\n  SLASH_SLASH,\n  BRACE_START,\n  BANG,\n  ONE_DOT,\n  TWO_DOTS,\n  GLOBSTAR,\n  SLASH_GLOBSTAR,\n  ANYMATCH_OPTS,\n  STRING_TYPE,\n  FUNCTION_TYPE,\n  EMPTY_STR,\n  EMPTY_FN,\n  isWindows,\n  isMacos,\n  isIBMi\n} = constants;\nconst stat = promisify(fs.stat);\nconst readdir = promisify(fs.readdir);\n\n/**\n * @typedef {String} Path\n * @typedef {'all'|'add'|'addDir'|'change'|'unlink'|'unlinkDir'|'raw'|'error'|'ready'} EventName\n * @typedef {'readdir'|'watch'|'add'|'remove'|'change'} ThrottleType\n */\n\n/**\n *\n * @typedef {Object} WatchHelpers\n * @property {Boolean} followSymlinks\n * @property {'stat'|'lstat'} statMethod\n * @property {Path} path\n * @property {Path} watchPath\n * @property {Function} entryPath\n * @property {Boolean} hasGlob\n * @property {Object} globFilter\n * @property {Function} filterPath\n * @property {Function} filterDir\n */\n\nconst arrify = function () {\n  let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return Array.isArray(value) ? value : [value];\n};\nconst flatten = function (list) {\n  let result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  list.forEach(item => {\n    if (Array.isArray(item)) {\n      flatten(item, result);\n    } else {\n      result.push(item);\n    }\n  });\n  return result;\n};\nconst unifyPaths = paths_ => {\n  /**\n   * @type {Array<String>}\n   */\n  const paths = flatten(arrify(paths_));\n  if (!paths.every(p => typeof p === STRING_TYPE)) {\n    throw new TypeError(`Non-string provided as watch path: ${paths}`);\n  }\n  return paths.map(normalizePathToUnix);\n};\n\n// If SLASH_SLASH occurs at the beginning of path, it is not replaced\n//     because \"//StoragePC/DrivePool/Movies\" is a valid network path\nconst toUnix = string => {\n  let str = string.replace(BACK_SLASH_RE, SLASH);\n  let prepend = false;\n  if (str.startsWith(SLASH_SLASH)) {\n    prepend = true;\n  }\n  while (str.match(DOUBLE_SLASH_RE)) {\n    str = str.replace(DOUBLE_SLASH_RE, SLASH);\n  }\n  if (prepend) {\n    str = SLASH + str;\n  }\n  return str;\n};\n\n// Our version of upath.normalize\n// TODO: this is not equal to path-normalize module - investigate why\nconst normalizePathToUnix = path => toUnix(sysPath.normalize(toUnix(path)));\nconst normalizeIgnored = function () {\n  let cwd = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : EMPTY_STR;\n  return path => {\n    if (typeof path !== STRING_TYPE) return path;\n    return normalizePathToUnix(sysPath.isAbsolute(path) ? path : sysPath.join(cwd, path));\n  };\n};\nconst getAbsolutePath = (path, cwd) => {\n  if (sysPath.isAbsolute(path)) {\n    return path;\n  }\n  if (path.startsWith(BANG)) {\n    return BANG + sysPath.join(cwd, path.slice(1));\n  }\n  return sysPath.join(cwd, path);\n};\nconst undef = (opts, key) => opts[key] === undefined;\n\n/**\n * Directory entry.\n * @property {Path} path\n * @property {Set<Path>} items\n */\nclass DirEntry {\n  /**\n   * @param {Path} dir\n   * @param {Function} removeWatcher\n   */\n  constructor(dir, removeWatcher) {\n    this.path = dir;\n    this._removeWatcher = removeWatcher;\n    /** @type {Set<Path>} */\n    this.items = new Set();\n  }\n  add(item) {\n    const {\n      items\n    } = this;\n    if (!items) return;\n    if (item !== ONE_DOT && item !== TWO_DOTS) items.add(item);\n  }\n  async remove(item) {\n    const {\n      items\n    } = this;\n    if (!items) return;\n    items.delete(item);\n    if (items.size > 0) return;\n    const dir = this.path;\n    try {\n      await readdir(dir);\n    } catch (err) {\n      if (this._removeWatcher) {\n        this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));\n      }\n    }\n  }\n  has(item) {\n    const {\n      items\n    } = this;\n    if (!items) return;\n    return items.has(item);\n  }\n\n  /**\n   * @returns {Array<String>}\n   */\n  getChildren() {\n    const {\n      items\n    } = this;\n    if (!items) return;\n    return [...items.values()];\n  }\n  dispose() {\n    this.items.clear();\n    delete this.path;\n    delete this._removeWatcher;\n    delete this.items;\n    Object.freeze(this);\n  }\n}\nconst STAT_METHOD_F = 'stat';\nconst STAT_METHOD_L = 'lstat';\nclass WatchHelper {\n  constructor(path, watchPath, follow, fsw) {\n    this.fsw = fsw;\n    this.path = path = path.replace(REPLACER_RE, EMPTY_STR);\n    this.watchPath = watchPath;\n    this.fullWatchPath = sysPath.resolve(watchPath);\n    this.hasGlob = watchPath !== path;\n    /** @type {object|boolean} */\n    if (path === EMPTY_STR) this.hasGlob = false;\n    this.globSymlink = this.hasGlob && follow ? undefined : false;\n    this.globFilter = this.hasGlob ? anymatch(path, undefined, ANYMATCH_OPTS) : false;\n    this.dirParts = this.getDirParts(path);\n    this.dirParts.forEach(parts => {\n      if (parts.length > 1) parts.pop();\n    });\n    this.followSymlinks = follow;\n    this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;\n  }\n  checkGlobSymlink(entry) {\n    // only need to resolve once\n    // first entry should always have entry.parentDir === EMPTY_STR\n    if (this.globSymlink === undefined) {\n      this.globSymlink = entry.fullParentDir === this.fullWatchPath ? false : {\n        realPath: entry.fullParentDir,\n        linkPath: this.fullWatchPath\n      };\n    }\n    if (this.globSymlink) {\n      return entry.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);\n    }\n    return entry.fullPath;\n  }\n  entryPath(entry) {\n    return sysPath.join(this.watchPath, sysPath.relative(this.watchPath, this.checkGlobSymlink(entry)));\n  }\n  filterPath(entry) {\n    const {\n      stats\n    } = entry;\n    if (stats && stats.isSymbolicLink()) return this.filterDir(entry);\n    const resolvedPath = this.entryPath(entry);\n    const matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE ? this.globFilter(resolvedPath) : true;\n    return matchesGlob && this.fsw._isntIgnored(resolvedPath, stats) && this.fsw._hasReadPermissions(stats);\n  }\n  getDirParts(path) {\n    if (!this.hasGlob) return [];\n    const parts = [];\n    const expandedPath = path.includes(BRACE_START) ? braces.expand(path) : [path];\n    expandedPath.forEach(path => {\n      parts.push(sysPath.relative(this.watchPath, path).split(SLASH_OR_BACK_SLASH_RE));\n    });\n    return parts;\n  }\n  filterDir(entry) {\n    if (this.hasGlob) {\n      const entryParts = this.getDirParts(this.checkGlobSymlink(entry));\n      let globstar = false;\n      this.unmatchedGlob = !this.dirParts.some(parts => {\n        return parts.every((part, i) => {\n          if (part === GLOBSTAR) globstar = true;\n          return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i], ANYMATCH_OPTS);\n        });\n      });\n    }\n    return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry), entry.stats);\n  }\n}\n\n/**\n * Watches files & directories for changes. Emitted events:\n * `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`\n *\n *     new FSWatcher()\n *       .add(directories)\n *       .on('add', path => log('File', path, 'was added'))\n */\nclass FSWatcher extends EventEmitter {\n  // Not indenting methods for history sake; for now.\n  constructor(_opts) {\n    var _this;\n    super();\n    _this = this;\n    const opts = {};\n    if (_opts) Object.assign(opts, _opts); // for frozen objects\n\n    /** @type {Map<String, DirEntry>} */\n    this._watched = new Map();\n    /** @type {Map<String, Array>} */\n    this._closers = new Map();\n    /** @type {Set<String>} */\n    this._ignoredPaths = new Set();\n\n    /** @type {Map<ThrottleType, Map>} */\n    this._throttled = new Map();\n\n    /** @type {Map<Path, String|Boolean>} */\n    this._symlinkPaths = new Map();\n    this._streams = new Set();\n    this.closed = false;\n\n    // Set up default options.\n    if (undef(opts, 'persistent')) opts.persistent = true;\n    if (undef(opts, 'ignoreInitial')) opts.ignoreInitial = false;\n    if (undef(opts, 'ignorePermissionErrors')) opts.ignorePermissionErrors = false;\n    if (undef(opts, 'interval')) opts.interval = 100;\n    if (undef(opts, 'binaryInterval')) opts.binaryInterval = 300;\n    if (undef(opts, 'disableGlobbing')) opts.disableGlobbing = false;\n    opts.enableBinaryInterval = opts.binaryInterval !== opts.interval;\n\n    // Enable fsevents on OS X when polling isn't explicitly enabled.\n    if (undef(opts, 'useFsEvents')) opts.useFsEvents = !opts.usePolling;\n\n    // If we can't use fsevents, ensure the options reflect it's disabled.\n    const canUseFsEvents = FsEventsHandler.canUse();\n    if (!canUseFsEvents) opts.useFsEvents = false;\n\n    // Use polling on Mac if not using fsevents.\n    // Other platforms use non-polling fs_watch.\n    if (undef(opts, 'usePolling') && !opts.useFsEvents) {\n      opts.usePolling = isMacos;\n    }\n\n    // Always default to polling on IBM i because fs.watch() is not available on IBM i.\n    if (isIBMi) {\n      opts.usePolling = true;\n    }\n\n    // Global override (useful for end-developers that need to force polling for all\n    // instances of chokidar, regardless of usage/dependency depth)\n    const envPoll = process.env.CHOKIDAR_USEPOLLING;\n    if (envPoll !== undefined) {\n      const envLower = envPoll.toLowerCase();\n      if (envLower === 'false' || envLower === '0') {\n        opts.usePolling = false;\n      } else if (envLower === 'true' || envLower === '1') {\n        opts.usePolling = true;\n      } else {\n        opts.usePolling = !!envLower;\n      }\n    }\n    const envInterval = process.env.CHOKIDAR_INTERVAL;\n    if (envInterval) {\n      opts.interval = Number.parseInt(envInterval, 10);\n    }\n\n    // Editor atomic write normalization enabled by default with fs.watch\n    if (undef(opts, 'atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;\n    if (opts.atomic) this._pendingUnlinks = new Map();\n    if (undef(opts, 'followSymlinks')) opts.followSymlinks = true;\n    if (undef(opts, 'awaitWriteFinish')) opts.awaitWriteFinish = false;\n    if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};\n    const awf = opts.awaitWriteFinish;\n    if (awf) {\n      if (!awf.stabilityThreshold) awf.stabilityThreshold = 2000;\n      if (!awf.pollInterval) awf.pollInterval = 100;\n      this._pendingWrites = new Map();\n    }\n    if (opts.ignored) opts.ignored = arrify(opts.ignored);\n    let readyCalls = 0;\n    this._emitReady = () => {\n      readyCalls++;\n      if (readyCalls >= this._readyCount) {\n        this._emitReady = EMPTY_FN;\n        this._readyEmitted = true;\n        // use process.nextTick to allow time for listener to be bound\n        process.nextTick(() => this.emit(EV_READY));\n      }\n    };\n    this._emitRaw = function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return _this.emit(EV_RAW, ...args);\n    };\n    this._readyEmitted = false;\n    this.options = opts;\n\n    // Initialize with proper watcher.\n    if (opts.useFsEvents) {\n      this._fsEventsHandler = new FsEventsHandler(this);\n    } else {\n      this._nodeFsHandler = new NodeFsHandler(this);\n    }\n\n    // You’re frozen when your heart’s not open.\n    Object.freeze(opts);\n  }\n\n  // Public methods\n\n  /**\n   * Adds paths to be watched on an existing FSWatcher instance\n   * @param {Path|Array<Path>} paths_\n   * @param {String=} _origAdd private; for handling non-existent paths to be watched\n   * @param {Boolean=} _internal private; indicates a non-user add\n   * @returns {FSWatcher} for chaining\n   */\n  add(paths_, _origAdd, _internal) {\n    const {\n      cwd,\n      disableGlobbing\n    } = this.options;\n    this.closed = false;\n    let paths = unifyPaths(paths_);\n    if (cwd) {\n      paths = paths.map(path => {\n        const absPath = getAbsolutePath(path, cwd);\n\n        // Check `path` instead of `absPath` because the cwd portion can't be a glob\n        if (disableGlobbing || !isGlob(path)) {\n          return absPath;\n        }\n        return normalizePath(absPath);\n      });\n    }\n\n    // set aside negated glob strings\n    paths = paths.filter(path => {\n      if (path.startsWith(BANG)) {\n        this._ignoredPaths.add(path.slice(1));\n        return false;\n      }\n\n      // if a path is being added that was previously ignored, stop ignoring it\n      this._ignoredPaths.delete(path);\n      this._ignoredPaths.delete(path + SLASH_GLOBSTAR);\n\n      // reset the cached userIgnored anymatch fn\n      // to make ignoredPaths changes effective\n      this._userIgnored = undefined;\n      return true;\n    });\n    if (this.options.useFsEvents && this._fsEventsHandler) {\n      if (!this._readyCount) this._readyCount = paths.length;\n      if (this.options.persistent) this._readyCount *= 2;\n      paths.forEach(path => this._fsEventsHandler._addToFsEvents(path));\n    } else {\n      if (!this._readyCount) this._readyCount = 0;\n      this._readyCount += paths.length;\n      Promise.all(paths.map(async path => {\n        const res = await this._nodeFsHandler._addToNodeFs(path, !_internal, 0, 0, _origAdd);\n        if (res) this._emitReady();\n        return res;\n      })).then(results => {\n        if (this.closed) return;\n        results.filter(item => item).forEach(item => {\n          this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));\n        });\n      });\n    }\n    return this;\n  }\n\n  /**\n   * Close watchers or start ignoring events from specified paths.\n   * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs\n   * @returns {FSWatcher} for chaining\n  */\n  unwatch(paths_) {\n    if (this.closed) return this;\n    const paths = unifyPaths(paths_);\n    const {\n      cwd\n    } = this.options;\n    paths.forEach(path => {\n      // convert to absolute path unless relative path already matches\n      if (!sysPath.isAbsolute(path) && !this._closers.has(path)) {\n        if (cwd) path = sysPath.join(cwd, path);\n        path = sysPath.resolve(path);\n      }\n      this._closePath(path);\n      this._ignoredPaths.add(path);\n      if (this._watched.has(path)) {\n        this._ignoredPaths.add(path + SLASH_GLOBSTAR);\n      }\n\n      // reset the cached userIgnored anymatch fn\n      // to make ignoredPaths changes effective\n      this._userIgnored = undefined;\n    });\n    return this;\n  }\n\n  /**\n   * Close watchers and remove all listeners from watched paths.\n   * @returns {Promise<void>}.\n  */\n  close() {\n    if (this.closed) return this._closePromise;\n    this.closed = true;\n\n    // Memory management.\n    this.removeAllListeners();\n    const closers = [];\n    this._closers.forEach(closerList => closerList.forEach(closer => {\n      const promise = closer();\n      if (promise instanceof Promise) closers.push(promise);\n    }));\n    this._streams.forEach(stream => stream.destroy());\n    this._userIgnored = undefined;\n    this._readyCount = 0;\n    this._readyEmitted = false;\n    this._watched.forEach(dirent => dirent.dispose());\n    ['closers', 'watched', 'streams', 'symlinkPaths', 'throttled'].forEach(key => {\n      this[`_${key}`].clear();\n    });\n    this._closePromise = closers.length ? Promise.all(closers).then(() => undefined) : Promise.resolve();\n    return this._closePromise;\n  }\n\n  /**\n   * Expose list of watched paths\n   * @returns {Object} for chaining\n  */\n  getWatched() {\n    const watchList = {};\n    this._watched.forEach((entry, dir) => {\n      const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;\n      watchList[key || ONE_DOT] = entry.getChildren().sort();\n    });\n    return watchList;\n  }\n  emitWithAll(event, args) {\n    this.emit(...args);\n    if (event !== EV_ERROR) this.emit(EV_ALL, ...args);\n  }\n\n  // Common helpers\n  // --------------\n\n  /**\n   * Normalize and emit events.\n   * Calling _emit DOES NOT MEAN emit() would be called!\n   * @param {EventName} event Type of event\n   * @param {Path} path File or directory path\n   * @param {*=} val1 arguments to be passed with event\n   * @param {*=} val2\n   * @param {*=} val3\n   * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n   */\n  async _emit(event, path, val1, val2, val3) {\n    if (this.closed) return;\n    const opts = this.options;\n    if (isWindows) path = sysPath.normalize(path);\n    if (opts.cwd) path = sysPath.relative(opts.cwd, path);\n    /** @type Array<any> */\n    const args = [event, path];\n    if (val3 !== undefined) args.push(val1, val2, val3);else if (val2 !== undefined) args.push(val1, val2);else if (val1 !== undefined) args.push(val1);\n    const awf = opts.awaitWriteFinish;\n    let pw;\n    if (awf && (pw = this._pendingWrites.get(path))) {\n      pw.lastChange = new Date();\n      return this;\n    }\n    if (opts.atomic) {\n      if (event === EV_UNLINK) {\n        this._pendingUnlinks.set(path, args);\n        setTimeout(() => {\n          this._pendingUnlinks.forEach((entry, path) => {\n            this.emit(...entry);\n            this.emit(EV_ALL, ...entry);\n            this._pendingUnlinks.delete(path);\n          });\n        }, typeof opts.atomic === 'number' ? opts.atomic : 100);\n        return this;\n      }\n      if (event === EV_ADD && this._pendingUnlinks.has(path)) {\n        event = args[0] = EV_CHANGE;\n        this._pendingUnlinks.delete(path);\n      }\n    }\n    if (awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted) {\n      const awfEmit = (err, stats) => {\n        if (err) {\n          event = args[0] = EV_ERROR;\n          args[1] = err;\n          this.emitWithAll(event, args);\n        } else if (stats) {\n          // if stats doesn't exist the file must have been deleted\n          if (args.length > 2) {\n            args[2] = stats;\n          } else {\n            args.push(stats);\n          }\n          this.emitWithAll(event, args);\n        }\n      };\n      this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);\n      return this;\n    }\n    if (event === EV_CHANGE) {\n      const isThrottled = !this._throttle(EV_CHANGE, path, 50);\n      if (isThrottled) return this;\n    }\n    if (opts.alwaysStat && val1 === undefined && (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE)) {\n      const fullPath = opts.cwd ? sysPath.join(opts.cwd, path) : path;\n      let stats;\n      try {\n        stats = await stat(fullPath);\n      } catch (err) {}\n      // Suppress event when fs_stat fails, to avoid sending undefined 'stat'\n      if (!stats || this.closed) return;\n      args.push(stats);\n    }\n    this.emitWithAll(event, args);\n    return this;\n  }\n\n  /**\n   * Common handler for errors\n   * @param {Error} error\n   * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n   */\n  _handleError(error) {\n    const code = error && error.code;\n    if (error && code !== 'ENOENT' && code !== 'ENOTDIR' && (!this.options.ignorePermissionErrors || code !== 'EPERM' && code !== 'EACCES')) {\n      this.emit(EV_ERROR, error);\n    }\n    return error || this.closed;\n  }\n\n  /**\n   * Helper utility for throttling\n   * @param {ThrottleType} actionType type being throttled\n   * @param {Path} path being acted upon\n   * @param {Number} timeout duration of time to suppress duplicate actions\n   * @returns {Object|false} tracking object or false if action should be suppressed\n   */\n  _throttle(actionType, path, timeout) {\n    if (!this._throttled.has(actionType)) {\n      this._throttled.set(actionType, new Map());\n    }\n\n    /** @type {Map<Path, Object>} */\n    const action = this._throttled.get(actionType);\n    /** @type {Object} */\n    const actionPath = action.get(path);\n    if (actionPath) {\n      actionPath.count++;\n      return false;\n    }\n    let timeoutObject;\n    const clear = () => {\n      const item = action.get(path);\n      const count = item ? item.count : 0;\n      action.delete(path);\n      clearTimeout(timeoutObject);\n      if (item) clearTimeout(item.timeoutObject);\n      return count;\n    };\n    timeoutObject = setTimeout(clear, timeout);\n    const thr = {\n      timeoutObject,\n      clear,\n      count: 0\n    };\n    action.set(path, thr);\n    return thr;\n  }\n  _incrReadyCount() {\n    return this._readyCount++;\n  }\n\n  /**\n   * Awaits write operation to finish.\n   * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.\n   * @param {Path} path being acted upon\n   * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished\n   * @param {EventName} event\n   * @param {Function} awfEmit Callback to be called when ready for event to be emitted.\n   */\n  _awaitWriteFinish(path, threshold, event, awfEmit) {\n    let timeoutHandler;\n    let fullPath = path;\n    if (this.options.cwd && !sysPath.isAbsolute(path)) {\n      fullPath = sysPath.join(this.options.cwd, path);\n    }\n    const now = new Date();\n    const awaitWriteFinish = prevStat => {\n      fs.stat(fullPath, (err, curStat) => {\n        if (err || !this._pendingWrites.has(path)) {\n          if (err && err.code !== 'ENOENT') awfEmit(err);\n          return;\n        }\n        const now = Number(new Date());\n        if (prevStat && curStat.size !== prevStat.size) {\n          this._pendingWrites.get(path).lastChange = now;\n        }\n        const pw = this._pendingWrites.get(path);\n        const df = now - pw.lastChange;\n        if (df >= threshold) {\n          this._pendingWrites.delete(path);\n          awfEmit(undefined, curStat);\n        } else {\n          timeoutHandler = setTimeout(awaitWriteFinish, this.options.awaitWriteFinish.pollInterval, curStat);\n        }\n      });\n    };\n    if (!this._pendingWrites.has(path)) {\n      this._pendingWrites.set(path, {\n        lastChange: now,\n        cancelWait: () => {\n          this._pendingWrites.delete(path);\n          clearTimeout(timeoutHandler);\n          return event;\n        }\n      });\n      timeoutHandler = setTimeout(awaitWriteFinish, this.options.awaitWriteFinish.pollInterval);\n    }\n  }\n  _getGlobIgnored() {\n    return [...this._ignoredPaths.values()];\n  }\n\n  /**\n   * Determines whether user has asked to ignore this path.\n   * @param {Path} path filepath or dir\n   * @param {fs.Stats=} stats result of fs.stat\n   * @returns {Boolean}\n   */\n  _isIgnored(path, stats) {\n    if (this.options.atomic && DOT_RE.test(path)) return true;\n    if (!this._userIgnored) {\n      const {\n        cwd\n      } = this.options;\n      const ign = this.options.ignored;\n      const ignored = ign && ign.map(normalizeIgnored(cwd));\n      const paths = arrify(ignored).filter(path => typeof path === STRING_TYPE && !isGlob(path)).map(path => path + SLASH_GLOBSTAR);\n      const list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);\n      this._userIgnored = anymatch(list, undefined, ANYMATCH_OPTS);\n    }\n    return this._userIgnored([path, stats]);\n  }\n  _isntIgnored(path, stat) {\n    return !this._isIgnored(path, stat);\n  }\n\n  /**\n   * Provides a set of common helpers and properties relating to symlink and glob handling.\n   * @param {Path} path file, directory, or glob pattern being watched\n   * @param {Number=} depth at any depth > 0, this isn't a glob\n   * @returns {WatchHelper} object containing helpers for this path\n   */\n  _getWatchHelpers(path, depth) {\n    const watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);\n    const follow = this.options.followSymlinks;\n    return new WatchHelper(path, watchPath, follow, this);\n  }\n\n  // Directory helpers\n  // -----------------\n\n  /**\n   * Provides directory tracking objects\n   * @param {String} directory path of the directory\n   * @returns {DirEntry} the directory's tracking object\n   */\n  _getWatchedDir(directory) {\n    if (!this._boundRemove) this._boundRemove = this._remove.bind(this);\n    const dir = sysPath.resolve(directory);\n    if (!this._watched.has(dir)) this._watched.set(dir, new DirEntry(dir, this._boundRemove));\n    return this._watched.get(dir);\n  }\n\n  // File helpers\n  // ------------\n\n  /**\n   * Check for read permissions.\n   * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405\n   * @param {fs.Stats} stats - object, result of fs_stat\n   * @returns {Boolean} indicates whether the file can be read\n  */\n  _hasReadPermissions(stats) {\n    if (this.options.ignorePermissionErrors) return true;\n\n    // stats.mode may be bigint\n    const md = stats && Number.parseInt(stats.mode, 10);\n    const st = md & 0o777;\n    const it = Number.parseInt(st.toString(8)[0], 10);\n    return Boolean(4 & it);\n  }\n\n  /**\n   * Handles emitting unlink events for\n   * files and directories, and via recursion, for\n   * files and directories within directories that are unlinked\n   * @param {String} directory within which the following item is located\n   * @param {String} item      base path of item/directory\n   * @returns {void}\n  */\n  _remove(directory, item, isDirectory) {\n    // if what is being deleted is a directory, get that directory's paths\n    // for recursive deleting and cleaning of watched object\n    // if it is not a directory, nestedDirectoryChildren will be empty array\n    const path = sysPath.join(directory, item);\n    const fullPath = sysPath.resolve(path);\n    isDirectory = isDirectory != null ? isDirectory : this._watched.has(path) || this._watched.has(fullPath);\n\n    // prevent duplicate handling in case of arriving here nearly simultaneously\n    // via multiple paths (such as _handleFile and _handleDir)\n    if (!this._throttle('remove', path, 100)) return;\n\n    // if the only watched file is removed, watch for its return\n    if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) {\n      this.add(directory, item, true);\n    }\n\n    // This will create a new entry in the watched object in either case\n    // so we got to do the directory check beforehand\n    const wp = this._getWatchedDir(path);\n    const nestedDirectoryChildren = wp.getChildren();\n\n    // Recursively remove children directories / files.\n    nestedDirectoryChildren.forEach(nested => this._remove(path, nested));\n\n    // Check if item was on the watched list and remove it\n    const parent = this._getWatchedDir(directory);\n    const wasTracked = parent.has(item);\n    parent.remove(item);\n\n    // Fixes issue #1042 -> Relative paths were detected and added as symlinks\n    // (https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L612),\n    // but never removed from the map in case the path was deleted.\n    // This leads to an incorrect state if the path was recreated:\n    // https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L553\n    if (this._symlinkPaths.has(fullPath)) {\n      this._symlinkPaths.delete(fullPath);\n    }\n\n    // If we wait for this file to be fully written, cancel the wait.\n    let relPath = path;\n    if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path);\n    if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {\n      const event = this._pendingWrites.get(relPath).cancelWait();\n      if (event === EV_ADD) return;\n    }\n\n    // The Entry will either be a directory that just got removed\n    // or a bogus entry to a file, in either case we have to remove it\n    this._watched.delete(path);\n    this._watched.delete(fullPath);\n    const eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK;\n    if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path);\n\n    // Avoid conflicts if we later create another file with the same name\n    if (!this.options.useFsEvents) {\n      this._closePath(path);\n    }\n  }\n\n  /**\n   * Closes all watchers for a path\n   * @param {Path} path\n   */\n  _closePath(path) {\n    this._closeFile(path);\n    const dir = sysPath.dirname(path);\n    this._getWatchedDir(dir).remove(sysPath.basename(path));\n  }\n\n  /**\n   * Closes only file-specific watchers\n   * @param {Path} path\n   */\n  _closeFile(path) {\n    const closers = this._closers.get(path);\n    if (!closers) return;\n    closers.forEach(closer => closer());\n    this._closers.delete(path);\n  }\n\n  /**\n   *\n   * @param {Path} path\n   * @param {Function} closer\n   */\n  _addPathCloser(path, closer) {\n    if (!closer) return;\n    let list = this._closers.get(path);\n    if (!list) {\n      list = [];\n      this._closers.set(path, list);\n    }\n    list.push(closer);\n  }\n  _readdirp(root, opts) {\n    if (this.closed) return;\n    const options = {\n      type: EV_ALL,\n      alwaysStat: true,\n      lstat: true,\n      ...opts\n    };\n    let stream = readdirp(root, options);\n    this._streams.add(stream);\n    stream.once(STR_CLOSE, () => {\n      stream = undefined;\n    });\n    stream.once(STR_END, () => {\n      if (stream) {\n        this._streams.delete(stream);\n        stream = undefined;\n      }\n    });\n    return stream;\n  }\n}\n\n// Export FSWatcher class\nchokidar.FSWatcher = FSWatcher;\n\n/**\n * Instantiates watcher with paths to be tracked.\n * @param {String|Array<String>} paths file/directory paths and/or globs\n * @param {Object=} options chokidar opts\n * @returns an instance of FSWatcher for chaining.\n */\nconst watch = (paths, options) => {\n  const watcher = new FSWatcher(options);\n  watcher.add(paths);\n  return watcher;\n};\nchokidar.watch = watch;\nclass FileWatcher {\n  constructor(task, chokidarOptions) {\n    this.transformWatchers = new Map();\n    this.chokidarOptions = chokidarOptions;\n    this.task = task;\n    this.watcher = this.createWatcher(null);\n  }\n  close() {\n    this.watcher.close();\n    for (const watcher of this.transformWatchers.values()) {\n      watcher.close();\n    }\n  }\n  unwatch(id) {\n    this.watcher.unwatch(id);\n    const transformWatcher = this.transformWatchers.get(id);\n    if (transformWatcher) {\n      this.transformWatchers.delete(id);\n      transformWatcher.close();\n    }\n  }\n  watch(id, isTransformDependency) {\n    if (isTransformDependency) {\n      const watcher = this.transformWatchers.get(id) ?? this.createWatcher(id);\n      watcher.add(id);\n      this.transformWatchers.set(id, watcher);\n    } else {\n      this.watcher.add(id);\n    }\n  }\n  createWatcher(transformWatcherId) {\n    const task = this.task;\n    const isLinux = platform() === 'linux';\n    const isTransformDependency = transformWatcherId !== null;\n    const handleChange = (id, event) => {\n      const changedId = transformWatcherId || id;\n      if (isLinux) {\n        // unwatching and watching fixes an issue with chokidar where on certain systems,\n        // a file that was unlinked and immediately recreated would create a change event\n        // but then no longer any further events\n        watcher.unwatch(changedId);\n        watcher.add(changedId);\n      }\n      task.invalidate(changedId, {\n        event,\n        isTransformDependency\n      });\n    };\n    const watcher = chokidar.watch([], this.chokidarOptions).on('add', id => handleChange(id, 'create')).on('change', id => handleChange(id, 'update')).on('unlink', id => handleChange(id, 'delete'));\n    return watcher;\n  }\n}\nconst eventsRewrites = {\n  create: {\n    create: 'buggy',\n    delete: null,\n    update: 'create'\n  },\n  delete: {\n    create: 'update',\n    delete: 'buggy',\n    update: 'buggy'\n  },\n  update: {\n    create: 'buggy',\n    delete: 'delete',\n    update: 'update'\n  }\n};\nclass Watcher {\n  constructor(optionsList, emitter) {\n    this.buildDelay = 0;\n    this.buildTimeout = null;\n    this.closed = false;\n    this.invalidatedIds = new Map();\n    this.rerun = false;\n    this.running = true;\n    this.emitter = emitter;\n    emitter.close = this.close.bind(this);\n    this.tasks = optionsList.map(options => new Task(this, options));\n    for (const {\n      watch\n    } of optionsList) {\n      if (watch && typeof watch.buildDelay === 'number') {\n        this.buildDelay = Math.max(this.buildDelay, watch.buildDelay);\n      }\n    }\n    process$1.nextTick(() => this.run());\n  }\n  async close() {\n    if (this.closed) return;\n    this.closed = true;\n    if (this.buildTimeout) clearTimeout(this.buildTimeout);\n    for (const task of this.tasks) {\n      task.close();\n    }\n    await this.emitter.emit('close');\n    this.emitter.removeAllListeners();\n  }\n  invalidate(file) {\n    if (file) {\n      const previousEvent = this.invalidatedIds.get(file.id);\n      const event = previousEvent ? eventsRewrites[previousEvent][file.event] : file.event;\n      if (event === 'buggy') {\n        //TODO: throws or warn? Currently just ignore, uses new event\n        this.invalidatedIds.set(file.id, file.event);\n      } else if (event === null) {\n        this.invalidatedIds.delete(file.id);\n      } else {\n        this.invalidatedIds.set(file.id, event);\n      }\n    }\n    if (this.running) {\n      this.rerun = true;\n      return;\n    }\n    if (this.buildTimeout) clearTimeout(this.buildTimeout);\n    this.buildTimeout = setTimeout(async () => {\n      this.buildTimeout = null;\n      try {\n        await Promise.all([...this.invalidatedIds].map(_ref => {\n          let [id, event] = _ref;\n          return this.emitter.emit('change', id, {\n            event\n          });\n        }));\n        this.invalidatedIds.clear();\n        await this.emitter.emit('restart');\n        this.emitter.removeListenersForCurrentRun();\n        this.run();\n      } catch (error) {\n        this.invalidatedIds.clear();\n        await this.emitter.emit('event', {\n          code: 'ERROR',\n          error,\n          result: null\n        });\n        await this.emitter.emit('event', {\n          code: 'END'\n        });\n      }\n    }, this.buildDelay);\n  }\n  async run() {\n    this.running = true;\n    await this.emitter.emit('event', {\n      code: 'START'\n    });\n    for (const task of this.tasks) {\n      await task.run();\n    }\n    this.running = false;\n    await this.emitter.emit('event', {\n      code: 'END'\n    });\n    if (this.rerun) {\n      this.rerun = false;\n      this.invalidate();\n    }\n  }\n}\nclass Task {\n  constructor(watcher, options) {\n    this.cache = {\n      modules: []\n    };\n    this.watchFiles = [];\n    this.closed = false;\n    this.invalidated = true;\n    this.watched = new Set();\n    this.watcher = watcher;\n    this.options = options;\n    this.skipWrite = Boolean(options.watch && options.watch.skipWrite);\n    this.outputs = this.options.output;\n    this.outputFiles = this.outputs.map(output => {\n      if (output.file || output.dir) return resolve(output.file || output.dir);\n      return undefined;\n    });\n    const watchOptions = this.options.watch || {};\n    this.filter = createFilter(watchOptions.include, watchOptions.exclude);\n    this.fileWatcher = new FileWatcher(this, {\n      ...watchOptions.chokidar,\n      disableGlobbing: true,\n      ignoreInitial: true\n    });\n  }\n  close() {\n    this.closed = true;\n    this.fileWatcher.close();\n  }\n  invalidate(id, details) {\n    this.invalidated = true;\n    if (details.isTransformDependency) {\n      for (const module of this.cache.modules) {\n        if (!module.transformDependencies.includes(id)) continue;\n        // effective invalidation\n        module.originalCode = null;\n      }\n    }\n    this.watcher.invalidate({\n      event: details.event,\n      id\n    });\n  }\n  async run() {\n    if (!this.invalidated) return;\n    this.invalidated = false;\n    const options = {\n      ...this.options,\n      cache: this.cache\n    };\n    const start = Date.now();\n    await this.watcher.emitter.emit('event', {\n      code: 'BUNDLE_START',\n      input: this.options.input,\n      output: this.outputFiles\n    });\n    let result = null;\n    try {\n      result = await rollupInternal(options, this.watcher.emitter);\n      if (this.closed) {\n        return;\n      }\n      this.updateWatchedFiles(result);\n      this.skipWrite || (await Promise.all(this.outputs.map(output => result.write(output))));\n      await this.watcher.emitter.emit('event', {\n        code: 'BUNDLE_END',\n        duration: Date.now() - start,\n        input: this.options.input,\n        output: this.outputFiles,\n        result\n      });\n    } catch (error) {\n      if (!this.closed) {\n        if (Array.isArray(error.watchFiles)) {\n          for (const id of error.watchFiles) {\n            this.watchFile(id);\n          }\n        }\n        if (error.id) {\n          this.cache.modules = this.cache.modules.filter(module => module.id !== error.id);\n        }\n      }\n      await this.watcher.emitter.emit('event', {\n        code: 'ERROR',\n        error,\n        result\n      });\n    }\n  }\n  updateWatchedFiles(result) {\n    const previouslyWatched = this.watched;\n    this.watched = new Set();\n    this.watchFiles = result.watchFiles;\n    this.cache = result.cache;\n    for (const id of this.watchFiles) {\n      this.watchFile(id);\n    }\n    for (const module of this.cache.modules) {\n      for (const depId of module.transformDependencies) {\n        this.watchFile(depId, true);\n      }\n    }\n    for (const id of previouslyWatched) {\n      if (!this.watched.has(id)) {\n        this.fileWatcher.unwatch(id);\n      }\n    }\n  }\n  watchFile(id) {\n    let isTransformDependency = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (!this.filter(id)) return;\n    this.watched.add(id);\n    if (this.outputFiles.includes(id)) {\n      throw new Error('Cannot import the generated bundle');\n    }\n    // this is necessary to ensure that any 'renamed' files\n    // continue to be watched following an error\n    this.fileWatcher.watch(id, isTransformDependency);\n  }\n}\nexport { Task, Watcher };","map":{"version":3,"names":["resolve","process$1","picomatchExports","getAugmentedNamespace","fseventsImporter","createFilter","rollupInternal","platform","require$$0$1","require$$2","require$$1","require$$0$2","require$$2$1","require$$0$3","chokidar","fs$3","Readable","sysPath$3","promisify","promisify$3","picomatch$1","readdir$1","readdir","stat$3","stat","lstat$2","lstat","realpath$1","realpath","BANG$2","RECURSIVE_ERROR_CODE","NORMAL_FLOW_ERRORS","Set","FILE_TYPE","DIR_TYPE","FILE_DIR_TYPE","EVERYTHING_TYPE","ALL_TYPES","isNormalFlowError","error","has","code","maj","min","process","versions","node","split","slice","map","n","Number","parseInt","wantBigintFsStats","normalizeFilter","filter","undefined","glob","trim","entry","basename","Array","isArray","positive","negative","item","trimmed","charAt","push","length","some","f","ReaddirpStream","defaultOptions","root","fileFilter","path","directoryFilter","type","depth","alwaysStat","constructor","options","arguments","objectMode","autoDestroy","highWaterMark","opts","_fileFilter","_directoryFilter","statMethod","_stat","bigint","_maxDepth","_wantsDir","includes","_wantsFile","_wantsEverything","_root","_isDirent","_statsProp","_rdOptions","encoding","withFileTypes","parents","_exploreDir","reading","parent","_read","batch","destroyed","files","splice","dirent","_formatEntry","Promise","all","entryType","_getEntryType","fullPath","_includeAsFile","pop","destroy","_onError","name","join","relative","err","emit","stats","isFile","isDirectory","isSymbolicLink","full","entryRealPath","entryRealPathStats","len","startsWith","substr","sep","recursiveError","Error","readdirp$1","TypeError","readdirpPromise","reject","on","promise","default","readdirp_1","anymatchExports","anymatch$2","exports","v","normalizePath$2","stripTrailing","prefix","ch","segs","Object","defineProperty","value","picomatch","normalizePath$1","BANG$1","DEFAULT_OPTIONS","returnIndex","arrify$1","createPattern","matcher","string","RegExp","test","matchPatterns","patterns","negPatterns","args","isList","_path","prototype","toString","call","index","nglob","applied","concat","pattern","anymatch$1","matchers","testString","mtchers","negatedGlobs","ri","isExtglob$1","isExtglob","str","match","exec","chars","strictCheck","pipeIndex","closeSquareIndex","closeCurlyIndex","closeParenIndex","backSlashIndex","indexOf","open","close","relaxedCheck","isGlob$2","isGlob","check","strict","isGlob$1","pathPosixDirname","posix","dirname","isWin32","slash","backslash","enclosure","globby","escaped","globParent$1","globParent","assign","flipBackslashes","replace","utils$3","isInteger","num","find","nodes","exceedsLimit","max","step","limit","escapeNode","block","encloseBrace","commas","ranges","invalid","isInvalidBrace","dollar","isOpenOrClose","reduce","acc","flatten","result","flat","arr","i","ele","_len","_key","utils$2","stringify$4","ast","stringify","invalidBlock","escapeInvalid","invalidNode","output","child","isNumber$2","isFinite","isNumber$1","toRegexRange$1","String","relaxZeros","strictZeros","relax","shorthand","capture","wrap","cacheKey","cache","hasOwnProperty","a","Math","b","abs","isPadded","hasPadding","state","positives","negatives","maxLen","newMin","splitToPatterns","collatePatterns","neg","pos","onlyNegative","filterPatterns","onlyPositive","intersected","subpatterns","splitToRanges","nines","zeros","stop","countNines","stops","add","countZeros","sort","compare","rangeToPattern","start","count","digits","zipped","zip","startDigit","stopDigit","toCharacterClass","tok","tokens","prev","obj","toQuantifier","padZeros","comparison","intersection","contains","key","val","repeat","integer","pow","diff","clearCache","toRegexRange_1","util","toRegexRange","isObject","transform","toNumber","isValidValue","isNumber","input","stringify$3","end","pad","maxLength","dash","padStart","toMaxLen","toSequence","parts","toRange","isNumbers","fromCharCode","toRegex","rangeError","RangeError","inspect","invalidRange","strictRanges","invalidStep","fillNumbers","descending","startString","endString","stepString","padded","format","range","fillLetters","charCodeAt","fill$2","fillRange","fill$1","utils$1","compile$1","walk","isOpen","isClose","compile_1","fill","stringify$2","utils","append","queue","stash","enclose","expand$1","rangeLimit","p","q","expand_1","constants$1","MAX_LENGTH","CHAR_0","CHAR_9","CHAR_UPPERCASE_A","CHAR_LOWERCASE_A","CHAR_UPPERCASE_Z","CHAR_LOWERCASE_Z","CHAR_LEFT_PARENTHESES","CHAR_RIGHT_PARENTHESES","CHAR_ASTERISK","CHAR_AMPERSAND","CHAR_AT","CHAR_BACKSLASH","CHAR_BACKTICK","CHAR_CARRIAGE_RETURN","CHAR_CIRCUMFLEX_ACCENT","CHAR_COLON","CHAR_COMMA","CHAR_DOLLAR","CHAR_DOT","CHAR_DOUBLE_QUOTE","CHAR_EQUAL","CHAR_EXCLAMATION_MARK","CHAR_FORM_FEED","CHAR_FORWARD_SLASH","CHAR_HASH","CHAR_HYPHEN_MINUS","CHAR_LEFT_ANGLE_BRACKET","CHAR_LEFT_CURLY_BRACE","CHAR_LEFT_SQUARE_BRACKET","CHAR_LINE_FEED","CHAR_NO_BREAK_SPACE","CHAR_PERCENT","CHAR_PLUS","CHAR_QUESTION_MARK","CHAR_RIGHT_ANGLE_BRACKET","CHAR_RIGHT_CURLY_BRACE","CHAR_RIGHT_SQUARE_BRACKET","CHAR_SEMICOLON","CHAR_SINGLE_QUOTE","CHAR_SPACE","CHAR_TAB","CHAR_UNDERSCORE","CHAR_VERTICAL_LINE","CHAR_ZERO_WIDTH_NOBREAK_SPACE","stringify$1","parse$1","SyntaxError","stack","brackets","advance","keepEscaping","next","keepQuotes","brace","shift","siblings","before","forEach","parse_1","compile","expand","parse","braces$1","create","nodupes","noempty","Boolean","braces_1","binaryExtensionsExports","binaryExtensions$1","require$$0","module","binaryExtensions","extensions","isBinaryPath$1","filePath","extname","toLowerCase","constants","os","EV_ALL","EV_READY","EV_ADD","EV_CHANGE","EV_ADD_DIR","EV_UNLINK","EV_UNLINK_DIR","EV_RAW","EV_ERROR","STR_DATA","STR_END","STR_CLOSE","FSEVENT_CREATED","FSEVENT_MODIFIED","FSEVENT_DELETED","FSEVENT_MOVED","FSEVENT_CLONED","FSEVENT_UNKNOWN","FSEVENT_TYPE_FILE","FSEVENT_TYPE_DIRECTORY","FSEVENT_TYPE_SYMLINK","KEY_LISTENERS","KEY_ERR","KEY_RAW","HANDLER_KEYS","DOT_SLASH","BACK_SLASH_RE","DOUBLE_SLASH_RE","SLASH_OR_BACK_SLASH_RE","DOT_RE","REPLACER_RE","SLASH","SLASH_SLASH","BRACE_START","BANG","ONE_DOT","TWO_DOTS","STAR","GLOBSTAR","ROOT_GLOBSTAR","SLASH_GLOBSTAR","DIR_SUFFIX","ANYMATCH_OPTS","dot","STRING_TYPE","FUNCTION_TYPE","EMPTY_STR","EMPTY_FN","IDENTITY_FN","isWindows","isMacos","isLinux","isIBMi","fs$2","sysPath$2","promisify$2","isBinaryPath","isWindows$1","EMPTY_FN$2","EMPTY_STR$1","EV_CHANGE$2","EV_ADD$2","EV_ADD_DIR$2","EV_ERROR$2","STR_DATA$1","STR_END$2","BRACE_START$1","THROTTLE_MODE_WATCH","stat$2","lstat$1","fsrealpath","statMethods$1","foreach","fn","addAndConvert","main","prop","container","clearItem","cont","set","clear","delFromSet","delete","isEmptySet","size","FsWatchInstances","Map","createFsWatchInstance","listener","errHandler","emitRaw","handleEvent","rawEvent","evPath","watchedPath","fsWatchBroadcast","watch","val1","val2","val3","get","setFsWatchListener","handlers","rawEmitter","watcher","persistent","bind","broadcastErr","watcherUnusable","fd","listeners","errHandlers","rawEmitters","freeze","FsWatchFileInstances","setFsWatchFileListener","copts","interval","unwatchFile","watchFile","curr","currmtime","mtimeMs","NodeFsHandler$1","NodeFsHandler","fsW","fsw","_boundHandleError","_handleError","_watchWithNodeFs","directory","_getWatchedDir","absolutePath","closer","usePolling","enableBinaryInterval","binaryInterval","_emitRaw","_handleFile","file","initialAdd","closed","prevStats","newStats","_throttle","at","atimeMs","mt","_emit","ino","_closeFile","_addPathCloser","_remove","ignoreInitial","_isntIgnored","_handleSymlink","dir","followSymlinks","_incrReadyCount","linkPath","e","_emitReady","_symlinkPaths","_handleRead","wh","target","throttler","hasGlob","previous","current","stream","_readdirp","filterPath","filterDir","_addToNodeFs","once","wasThrottled","getChildren","_handleDir","parentDir","tracked","globFilter","oDepth","dirPath","priorWh","ready","_isIgnored","_getWatchHelpers","watchPath","follow","absPath","targetPath","nodefsHandler","fseventsHandlerExports","fseventsHandler","require$$3","fs$1","sysPath$1","promisify$1","fsevents","getFsEvents","env","CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR","console","mtch","version","EV_ADD$1","EV_CHANGE$1","EV_ADD_DIR$1","EV_UNLINK$1","EV_ERROR$1","STR_END$1","FUNCTION_TYPE$1","EMPTY_FN$1","Depth","isNaN","stat$1","statMethods","FSEventsWatchers","consolidateThreshhold","wrongEventFlags","createFSEventsInstance","callback","setFSEventsListener","realPath","parentPath","couldConsolidate","resolvedPath","hasSymlink","filteredListener","flags","info","watchedParent","keys","getInfo","list","event","lst","then","canUse","calcDepth","sameTypes","FsEventsHandler$1","FsEventsHandler","checkIgnored","ipaths","_ignoredPaths","addOrChange","watchedDir","checkExists","curDepth","_addToFsEvents","eventName","_watchWithFsEvents","watchCallback","ignored","_handleFsEventsSymlink","linkTarget","aliasedPath","emitAdd","newPath","processPath","forceAdd","pp","isDir","dirObj","base","initWatch","priorDepth","joinedPath","EventEmitter","fs","sysPath","readdirp","anymatch","braces","normalizePath","arrify","unifyPaths","paths_","paths","every","normalizePathToUnix","toUnix","prepend","normalize","normalizeIgnored","cwd","isAbsolute","getAbsolutePath","undef","DirEntry","removeWatcher","_removeWatcher","items","remove","values","dispose","STAT_METHOD_F","STAT_METHOD_L","WatchHelper","fullWatchPath","globSymlink","dirParts","getDirParts","checkGlobSymlink","fullParentDir","entryPath","matchesGlob","_hasReadPermissions","expandedPath","entryParts","globstar","unmatchedGlob","part","FSWatcher","_opts","_this","this","_watched","_closers","_throttled","_streams","ignorePermissionErrors","disableGlobbing","useFsEvents","canUseFsEvents","envPoll","CHOKIDAR_USEPOLLING","envLower","envInterval","CHOKIDAR_INTERVAL","atomic","_pendingUnlinks","awaitWriteFinish","awf","stabilityThreshold","pollInterval","_pendingWrites","readyCalls","_readyCount","_readyEmitted","nextTick","_len2","_key2","_fsEventsHandler","_nodeFsHandler","_origAdd","_internal","_userIgnored","res","results","unwatch","_closePath","_closePromise","removeAllListeners","closers","closerList","getWatched","watchList","emitWithAll","pw","lastChange","Date","setTimeout","awfEmit","_awaitWriteFinish","isThrottled","actionType","timeout","action","actionPath","timeoutObject","clearTimeout","thr","threshold","timeoutHandler","now","prevStat","curStat","df","cancelWait","_getGlobIgnored","ign","_boundRemove","md","mode","st","it","wp","nestedDirectoryChildren","nested","wasTracked","relPath","FileWatcher","task","chokidarOptions","transformWatchers","createWatcher","id","transformWatcher","isTransformDependency","transformWatcherId","handleChange","changedId","invalidate","eventsRewrites","update","Watcher","optionsList","emitter","buildDelay","buildTimeout","invalidatedIds","rerun","running","tasks","Task","run","previousEvent","_ref","removeListenersForCurrentRun","modules","watchFiles","invalidated","watched","skipWrite","outputs","outputFiles","watchOptions","include","exclude","fileWatcher","details","transformDependencies","originalCode","updateWatchedFiles","write","duration","previouslyWatched","depId"],"sources":["/Users/hrushi/node_modules/rollup/dist/es/shared/watch.js"],"sourcesContent":["/*\n  @license\n\tRollup.js v3.18.0\n\tWed, 01 Mar 2023 18:45:12 GMT - commit 25bdc129d21685b69a00ee55397d42ac6eff6449\n\n\thttps://github.com/rollup/rollup\n\n\tReleased under the MIT License.\n*/\nimport { resolve } from 'node:path';\nimport process$1 from 'node:process';\nimport { picomatchExports, getAugmentedNamespace, fseventsImporter, createFilter, rollupInternal } from './node-entry.js';\nimport { platform } from 'node:os';\nimport require$$0$1 from 'fs';\nimport require$$2 from 'util';\nimport require$$1 from 'stream';\nimport require$$0$2 from 'path';\nimport require$$2$1 from 'os';\nimport require$$0$3 from 'events';\nimport 'node:perf_hooks';\nimport 'node:crypto';\nimport 'node:fs/promises';\nimport 'node:events';\nimport 'tty';\n\nvar chokidar = {};\n\nconst fs$3 = require$$0$1;\nconst { Readable } = require$$1;\nconst sysPath$3 = require$$0$2;\nconst { promisify: promisify$3 } = require$$2;\nconst picomatch$1 = picomatchExports;\n\nconst readdir$1 = promisify$3(fs$3.readdir);\nconst stat$3 = promisify$3(fs$3.stat);\nconst lstat$2 = promisify$3(fs$3.lstat);\nconst realpath$1 = promisify$3(fs$3.realpath);\n\n/**\n * @typedef {Object} EntryInfo\n * @property {String} path\n * @property {String} fullPath\n * @property {fs.Stats=} stats\n * @property {fs.Dirent=} dirent\n * @property {String} basename\n */\n\nconst BANG$2 = '!';\nconst RECURSIVE_ERROR_CODE = 'READDIRP_RECURSIVE_ERROR';\nconst NORMAL_FLOW_ERRORS = new Set(['ENOENT', 'EPERM', 'EACCES', 'ELOOP', RECURSIVE_ERROR_CODE]);\nconst FILE_TYPE = 'files';\nconst DIR_TYPE = 'directories';\nconst FILE_DIR_TYPE = 'files_directories';\nconst EVERYTHING_TYPE = 'all';\nconst ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];\n\nconst isNormalFlowError = error => NORMAL_FLOW_ERRORS.has(error.code);\nconst [maj, min] = process.versions.node.split('.').slice(0, 2).map(n => Number.parseInt(n, 10));\nconst wantBigintFsStats = process.platform === 'win32' && (maj > 10 || (maj === 10 && min >= 5));\n\nconst normalizeFilter = filter => {\n  if (filter === undefined) return;\n  if (typeof filter === 'function') return filter;\n\n  if (typeof filter === 'string') {\n    const glob = picomatch$1(filter.trim());\n    return entry => glob(entry.basename);\n  }\n\n  if (Array.isArray(filter)) {\n    const positive = [];\n    const negative = [];\n    for (const item of filter) {\n      const trimmed = item.trim();\n      if (trimmed.charAt(0) === BANG$2) {\n        negative.push(picomatch$1(trimmed.slice(1)));\n      } else {\n        positive.push(picomatch$1(trimmed));\n      }\n    }\n\n    if (negative.length > 0) {\n      if (positive.length > 0) {\n        return entry =>\n          positive.some(f => f(entry.basename)) && !negative.some(f => f(entry.basename));\n      }\n      return entry => !negative.some(f => f(entry.basename));\n    }\n    return entry => positive.some(f => f(entry.basename));\n  }\n};\n\nclass ReaddirpStream extends Readable {\n  static get defaultOptions() {\n    return {\n      root: '.',\n      /* eslint-disable no-unused-vars */\n      fileFilter: (path) => true,\n      directoryFilter: (path) => true,\n      /* eslint-enable no-unused-vars */\n      type: FILE_TYPE,\n      lstat: false,\n      depth: 2147483648,\n      alwaysStat: false\n    };\n  }\n\n  constructor(options = {}) {\n    super({\n      objectMode: true,\n      autoDestroy: true,\n      highWaterMark: options.highWaterMark || 4096\n    });\n    const opts = { ...ReaddirpStream.defaultOptions, ...options };\n    const { root, type } = opts;\n\n    this._fileFilter = normalizeFilter(opts.fileFilter);\n    this._directoryFilter = normalizeFilter(opts.directoryFilter);\n\n    const statMethod = opts.lstat ? lstat$2 : stat$3;\n    // Use bigint stats if it's windows and stat() supports options (node 10+).\n    if (wantBigintFsStats) {\n      this._stat = path => statMethod(path, { bigint: true });\n    } else {\n      this._stat = statMethod;\n    }\n\n    this._maxDepth = opts.depth;\n    this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsEverything = type === EVERYTHING_TYPE;\n    this._root = sysPath$3.resolve(root);\n    this._isDirent = ('Dirent' in fs$3) && !opts.alwaysStat;\n    this._statsProp = this._isDirent ? 'dirent' : 'stats';\n    this._rdOptions = { encoding: 'utf8', withFileTypes: this._isDirent };\n\n    // Launch stream with one parent, the root dir.\n    this.parents = [this._exploreDir(root, 1)];\n    this.reading = false;\n    this.parent = undefined;\n  }\n\n  async _read(batch) {\n    if (this.reading) return;\n    this.reading = true;\n\n    try {\n      while (!this.destroyed && batch > 0) {\n        const { path, depth, files = [] } = this.parent || {};\n\n        if (files.length > 0) {\n          const slice = files.splice(0, batch).map(dirent => this._formatEntry(dirent, path));\n          for (const entry of await Promise.all(slice)) {\n            if (this.destroyed) return;\n\n            const entryType = await this._getEntryType(entry);\n            if (entryType === 'directory' && this._directoryFilter(entry)) {\n              if (depth <= this._maxDepth) {\n                this.parents.push(this._exploreDir(entry.fullPath, depth + 1));\n              }\n\n              if (this._wantsDir) {\n                this.push(entry);\n                batch--;\n              }\n            } else if ((entryType === 'file' || this._includeAsFile(entry)) && this._fileFilter(entry)) {\n              if (this._wantsFile) {\n                this.push(entry);\n                batch--;\n              }\n            }\n          }\n        } else {\n          const parent = this.parents.pop();\n          if (!parent) {\n            this.push(null);\n            break;\n          }\n          this.parent = await parent;\n          if (this.destroyed) return;\n        }\n      }\n    } catch (error) {\n      this.destroy(error);\n    } finally {\n      this.reading = false;\n    }\n  }\n\n  async _exploreDir(path, depth) {\n    let files;\n    try {\n      files = await readdir$1(path, this._rdOptions);\n    } catch (error) {\n      this._onError(error);\n    }\n    return { files, depth, path };\n  }\n\n  async _formatEntry(dirent, path) {\n    let entry;\n    try {\n      const basename = this._isDirent ? dirent.name : dirent;\n      const fullPath = sysPath$3.resolve(sysPath$3.join(path, basename));\n      entry = { path: sysPath$3.relative(this._root, fullPath), fullPath, basename };\n      entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);\n    } catch (err) {\n      this._onError(err);\n    }\n    return entry;\n  }\n\n  _onError(err) {\n    if (isNormalFlowError(err) && !this.destroyed) {\n      this.emit('warn', err);\n    } else {\n      this.destroy(err);\n    }\n  }\n\n  async _getEntryType(entry) {\n    // entry may be undefined, because a warning or an error were emitted\n    // and the statsProp is undefined\n    const stats = entry && entry[this._statsProp];\n    if (!stats) {\n      return;\n    }\n    if (stats.isFile()) {\n      return 'file';\n    }\n    if (stats.isDirectory()) {\n      return 'directory';\n    }\n    if (stats && stats.isSymbolicLink()) {\n      const full = entry.fullPath;\n      try {\n        const entryRealPath = await realpath$1(full);\n        const entryRealPathStats = await lstat$2(entryRealPath);\n        if (entryRealPathStats.isFile()) {\n          return 'file';\n        }\n        if (entryRealPathStats.isDirectory()) {\n          const len = entryRealPath.length;\n          if (full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath$3.sep) {\n            const recursiveError = new Error(\n              `Circular symlink detected: \"${full}\" points to \"${entryRealPath}\"`\n            );\n            recursiveError.code = RECURSIVE_ERROR_CODE;\n            return this._onError(recursiveError);\n          }\n          return 'directory';\n        }\n      } catch (error) {\n        this._onError(error);\n      }\n    }\n  }\n\n  _includeAsFile(entry) {\n    const stats = entry && entry[this._statsProp];\n\n    return stats && this._wantsEverything && !stats.isDirectory();\n  }\n}\n\n/**\n * @typedef {Object} ReaddirpArguments\n * @property {Function=} fileFilter\n * @property {Function=} directoryFilter\n * @property {String=} type\n * @property {Number=} depth\n * @property {String=} root\n * @property {Boolean=} lstat\n * @property {Boolean=} bigint\n */\n\n/**\n * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.\n * @param {String} root Root directory\n * @param {ReaddirpArguments=} options Options to specify root (start directory), filters and recursion depth\n */\nconst readdirp$1 = (root, options = {}) => {\n  let type = options.entryType || options.type;\n  if (type === 'both') type = FILE_DIR_TYPE; // backwards-compatibility\n  if (type) options.type = type;\n  if (!root) {\n    throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');\n  } else if (typeof root !== 'string') {\n    throw new TypeError('readdirp: root argument must be a string. Usage: readdirp(root, options)');\n  } else if (type && !ALL_TYPES.includes(type)) {\n    throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(', ')}`);\n  }\n\n  options.root = root;\n  return new ReaddirpStream(options);\n};\n\nconst readdirpPromise = (root, options = {}) => {\n  return new Promise((resolve, reject) => {\n    const files = [];\n    readdirp$1(root, options)\n      .on('data', entry => files.push(entry))\n      .on('end', () => resolve(files))\n      .on('error', error => reject(error));\n  });\n};\n\nreaddirp$1.promise = readdirpPromise;\nreaddirp$1.ReaddirpStream = ReaddirpStream;\nreaddirp$1.default = readdirp$1;\n\nvar readdirp_1 = readdirp$1;\n\nvar anymatchExports = {};\nvar anymatch$2 = {\n  get exports(){ return anymatchExports; },\n  set exports(v){ anymatchExports = v; },\n};\n\n/*!\n * normalize-path <https://github.com/jonschlinkert/normalize-path>\n *\n * Copyright (c) 2014-2018, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nvar normalizePath$2 = function(path, stripTrailing) {\n  if (typeof path !== 'string') {\n    throw new TypeError('expected path to be a string');\n  }\n\n  if (path === '\\\\' || path === '/') return '/';\n\n  var len = path.length;\n  if (len <= 1) return path;\n\n  // ensure that win32 namespaces has two leading slashes, so that the path is\n  // handled properly by the win32 version of path.parse() after being normalized\n  // https://msdn.microsoft.com/library/windows/desktop/aa365247(v=vs.85).aspx#namespaces\n  var prefix = '';\n  if (len > 4 && path[3] === '\\\\') {\n    var ch = path[2];\n    if ((ch === '?' || ch === '.') && path.slice(0, 2) === '\\\\\\\\') {\n      path = path.slice(2);\n      prefix = '//';\n    }\n  }\n\n  var segs = path.split(/[/\\\\]+/);\n  if (stripTrailing !== false && segs[segs.length - 1] === '') {\n    segs.pop();\n  }\n  return prefix + segs.join('/');\n};\n\nObject.defineProperty(anymatchExports, \"__esModule\", { value: true });\n\nconst picomatch = picomatchExports;\nconst normalizePath$1 = normalizePath$2;\n\n/**\n * @typedef {(testString: string) => boolean} AnymatchFn\n * @typedef {string|RegExp|AnymatchFn} AnymatchPattern\n * @typedef {AnymatchPattern|AnymatchPattern[]} AnymatchMatcher\n */\nconst BANG$1 = '!';\nconst DEFAULT_OPTIONS = {returnIndex: false};\nconst arrify$1 = (item) => Array.isArray(item) ? item : [item];\n\n/**\n * @param {AnymatchPattern} matcher\n * @param {object} options\n * @returns {AnymatchFn}\n */\nconst createPattern = (matcher, options) => {\n  if (typeof matcher === 'function') {\n    return matcher;\n  }\n  if (typeof matcher === 'string') {\n    const glob = picomatch(matcher, options);\n    return (string) => matcher === string || glob(string);\n  }\n  if (matcher instanceof RegExp) {\n    return (string) => matcher.test(string);\n  }\n  return (string) => false;\n};\n\n/**\n * @param {Array<Function>} patterns\n * @param {Array<Function>} negPatterns\n * @param {String|Array} args\n * @param {Boolean} returnIndex\n * @returns {boolean|number}\n */\nconst matchPatterns = (patterns, negPatterns, args, returnIndex) => {\n  const isList = Array.isArray(args);\n  const _path = isList ? args[0] : args;\n  if (!isList && typeof _path !== 'string') {\n    throw new TypeError('anymatch: second argument must be a string: got ' +\n      Object.prototype.toString.call(_path))\n  }\n  const path = normalizePath$1(_path, false);\n\n  for (let index = 0; index < negPatterns.length; index++) {\n    const nglob = negPatterns[index];\n    if (nglob(path)) {\n      return returnIndex ? -1 : false;\n    }\n  }\n\n  const applied = isList && [path].concat(args.slice(1));\n  for (let index = 0; index < patterns.length; index++) {\n    const pattern = patterns[index];\n    if (isList ? pattern(...applied) : pattern(path)) {\n      return returnIndex ? index : true;\n    }\n  }\n\n  return returnIndex ? -1 : false;\n};\n\n/**\n * @param {AnymatchMatcher} matchers\n * @param {Array|string} testString\n * @param {object} options\n * @returns {boolean|number|Function}\n */\nconst anymatch$1 = (matchers, testString, options = DEFAULT_OPTIONS) => {\n  if (matchers == null) {\n    throw new TypeError('anymatch: specify first argument');\n  }\n  const opts = typeof options === 'boolean' ? {returnIndex: options} : options;\n  const returnIndex = opts.returnIndex || false;\n\n  // Early cache for matchers.\n  const mtchers = arrify$1(matchers);\n  const negatedGlobs = mtchers\n    .filter(item => typeof item === 'string' && item.charAt(0) === BANG$1)\n    .map(item => item.slice(1))\n    .map(item => picomatch(item, opts));\n  const patterns = mtchers\n    .filter(item => typeof item !== 'string' || (typeof item === 'string' && item.charAt(0) !== BANG$1))\n    .map(matcher => createPattern(matcher, opts));\n\n  if (testString == null) {\n    return (testString, ri = false) => {\n      const returnIndex = typeof ri === 'boolean' ? ri : false;\n      return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n    }\n  }\n\n  return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n};\n\nanymatch$1.default = anymatch$1;\nanymatch$2.exports = anymatch$1;\n\n/*!\n * is-extglob <https://github.com/jonschlinkert/is-extglob>\n *\n * Copyright (c) 2014-2016, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\nvar isExtglob$1 = function isExtglob(str) {\n  if (typeof str !== 'string' || str === '') {\n    return false;\n  }\n\n  var match;\n  while ((match = /(\\\\).|([@?!+*]\\(.*\\))/g.exec(str))) {\n    if (match[2]) return true;\n    str = str.slice(match.index + match[0].length);\n  }\n\n  return false;\n};\n\n/*!\n * is-glob <https://github.com/jonschlinkert/is-glob>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nvar isExtglob = isExtglob$1;\nvar chars = { '{': '}', '(': ')', '[': ']'};\nvar strictCheck = function(str) {\n  if (str[0] === '!') {\n    return true;\n  }\n  var index = 0;\n  var pipeIndex = -2;\n  var closeSquareIndex = -2;\n  var closeCurlyIndex = -2;\n  var closeParenIndex = -2;\n  var backSlashIndex = -2;\n  while (index < str.length) {\n    if (str[index] === '*') {\n      return true;\n    }\n\n    if (str[index + 1] === '?' && /[\\].+)]/.test(str[index])) {\n      return true;\n    }\n\n    if (closeSquareIndex !== -1 && str[index] === '[' && str[index + 1] !== ']') {\n      if (closeSquareIndex < index) {\n        closeSquareIndex = str.indexOf(']', index);\n      }\n      if (closeSquareIndex > index) {\n        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {\n          return true;\n        }\n        backSlashIndex = str.indexOf('\\\\', index);\n        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {\n          return true;\n        }\n      }\n    }\n\n    if (closeCurlyIndex !== -1 && str[index] === '{' && str[index + 1] !== '}') {\n      closeCurlyIndex = str.indexOf('}', index);\n      if (closeCurlyIndex > index) {\n        backSlashIndex = str.indexOf('\\\\', index);\n        if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {\n          return true;\n        }\n      }\n    }\n\n    if (closeParenIndex !== -1 && str[index] === '(' && str[index + 1] === '?' && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ')') {\n      closeParenIndex = str.indexOf(')', index);\n      if (closeParenIndex > index) {\n        backSlashIndex = str.indexOf('\\\\', index);\n        if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {\n          return true;\n        }\n      }\n    }\n\n    if (pipeIndex !== -1 && str[index] === '(' && str[index + 1] !== '|') {\n      if (pipeIndex < index) {\n        pipeIndex = str.indexOf('|', index);\n      }\n      if (pipeIndex !== -1 && str[pipeIndex + 1] !== ')') {\n        closeParenIndex = str.indexOf(')', pipeIndex);\n        if (closeParenIndex > pipeIndex) {\n          backSlashIndex = str.indexOf('\\\\', pipeIndex);\n          if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {\n            return true;\n          }\n        }\n      }\n    }\n\n    if (str[index] === '\\\\') {\n      var open = str[index + 1];\n      index += 2;\n      var close = chars[open];\n\n      if (close) {\n        var n = str.indexOf(close, index);\n        if (n !== -1) {\n          index = n + 1;\n        }\n      }\n\n      if (str[index] === '!') {\n        return true;\n      }\n    } else {\n      index++;\n    }\n  }\n  return false;\n};\n\nvar relaxedCheck = function(str) {\n  if (str[0] === '!') {\n    return true;\n  }\n  var index = 0;\n  while (index < str.length) {\n    if (/[*?{}()[\\]]/.test(str[index])) {\n      return true;\n    }\n\n    if (str[index] === '\\\\') {\n      var open = str[index + 1];\n      index += 2;\n      var close = chars[open];\n\n      if (close) {\n        var n = str.indexOf(close, index);\n        if (n !== -1) {\n          index = n + 1;\n        }\n      }\n\n      if (str[index] === '!') {\n        return true;\n      }\n    } else {\n      index++;\n    }\n  }\n  return false;\n};\n\nvar isGlob$2 = function isGlob(str, options) {\n  if (typeof str !== 'string' || str === '') {\n    return false;\n  }\n\n  if (isExtglob(str)) {\n    return true;\n  }\n\n  var check = strictCheck;\n\n  // optionally relax check\n  if (options && options.strict === false) {\n    check = relaxedCheck;\n  }\n\n  return check(str);\n};\n\nvar isGlob$1 = isGlob$2;\nvar pathPosixDirname = require$$0$2.posix.dirname;\nvar isWin32 = require$$2$1.platform() === 'win32';\n\nvar slash = '/';\nvar backslash = /\\\\/g;\nvar enclosure = /[\\{\\[].*[\\}\\]]$/;\nvar globby = /(^|[^\\\\])([\\{\\[]|\\([^\\)]+$)/;\nvar escaped = /\\\\([\\!\\*\\?\\|\\[\\]\\(\\)\\{\\}])/g;\n\n/**\n * @param {string} str\n * @param {Object} opts\n * @param {boolean} [opts.flipBackslashes=true]\n * @returns {string}\n */\nvar globParent$1 = function globParent(str, opts) {\n  var options = Object.assign({ flipBackslashes: true }, opts);\n\n  // flip windows path separators\n  if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {\n    str = str.replace(backslash, slash);\n  }\n\n  // special case for strings ending in enclosure containing path separator\n  if (enclosure.test(str)) {\n    str += slash;\n  }\n\n  // preserves full path in case of trailing path separator\n  str += 'a';\n\n  // remove path parts that are globby\n  do {\n    str = pathPosixDirname(str);\n  } while (isGlob$1(str) || globby.test(str));\n\n  // remove escape chars and return result\n  return str.replace(escaped, '$1');\n};\n\nvar utils$3 = {};\n\n(function (exports) {\n\n\texports.isInteger = num => {\n\t  if (typeof num === 'number') {\n\t    return Number.isInteger(num);\n\t  }\n\t  if (typeof num === 'string' && num.trim() !== '') {\n\t    return Number.isInteger(Number(num));\n\t  }\n\t  return false;\n\t};\n\n\t/**\n\t * Find a node of the given type\n\t */\n\n\texports.find = (node, type) => node.nodes.find(node => node.type === type);\n\n\t/**\n\t * Find a node of the given type\n\t */\n\n\texports.exceedsLimit = (min, max, step = 1, limit) => {\n\t  if (limit === false) return false;\n\t  if (!exports.isInteger(min) || !exports.isInteger(max)) return false;\n\t  return ((Number(max) - Number(min)) / Number(step)) >= limit;\n\t};\n\n\t/**\n\t * Escape the given node with '\\\\' before node.value\n\t */\n\n\texports.escapeNode = (block, n = 0, type) => {\n\t  let node = block.nodes[n];\n\t  if (!node) return;\n\n\t  if ((type && node.type === type) || node.type === 'open' || node.type === 'close') {\n\t    if (node.escaped !== true) {\n\t      node.value = '\\\\' + node.value;\n\t      node.escaped = true;\n\t    }\n\t  }\n\t};\n\n\t/**\n\t * Returns true if the given brace node should be enclosed in literal braces\n\t */\n\n\texports.encloseBrace = node => {\n\t  if (node.type !== 'brace') return false;\n\t  if ((node.commas >> 0 + node.ranges >> 0) === 0) {\n\t    node.invalid = true;\n\t    return true;\n\t  }\n\t  return false;\n\t};\n\n\t/**\n\t * Returns true if a brace node is invalid.\n\t */\n\n\texports.isInvalidBrace = block => {\n\t  if (block.type !== 'brace') return false;\n\t  if (block.invalid === true || block.dollar) return true;\n\t  if ((block.commas >> 0 + block.ranges >> 0) === 0) {\n\t    block.invalid = true;\n\t    return true;\n\t  }\n\t  if (block.open !== true || block.close !== true) {\n\t    block.invalid = true;\n\t    return true;\n\t  }\n\t  return false;\n\t};\n\n\t/**\n\t * Returns true if a node is an open or close node\n\t */\n\n\texports.isOpenOrClose = node => {\n\t  if (node.type === 'open' || node.type === 'close') {\n\t    return true;\n\t  }\n\t  return node.open === true || node.close === true;\n\t};\n\n\t/**\n\t * Reduce an array of text nodes.\n\t */\n\n\texports.reduce = nodes => nodes.reduce((acc, node) => {\n\t  if (node.type === 'text') acc.push(node.value);\n\t  if (node.type === 'range') node.type = 'text';\n\t  return acc;\n\t}, []);\n\n\t/**\n\t * Flatten an array\n\t */\n\n\texports.flatten = (...args) => {\n\t  const result = [];\n\t  const flat = arr => {\n\t    for (let i = 0; i < arr.length; i++) {\n\t      let ele = arr[i];\n\t      Array.isArray(ele) ? flat(ele) : ele !== void 0 && result.push(ele);\n\t    }\n\t    return result;\n\t  };\n\t  flat(args);\n\t  return result;\n\t};\n} (utils$3));\n\nconst utils$2 = utils$3;\n\nvar stringify$4 = (ast, options = {}) => {\n  let stringify = (node, parent = {}) => {\n    let invalidBlock = options.escapeInvalid && utils$2.isInvalidBrace(parent);\n    let invalidNode = node.invalid === true && options.escapeInvalid === true;\n    let output = '';\n\n    if (node.value) {\n      if ((invalidBlock || invalidNode) && utils$2.isOpenOrClose(node)) {\n        return '\\\\' + node.value;\n      }\n      return node.value;\n    }\n\n    if (node.value) {\n      return node.value;\n    }\n\n    if (node.nodes) {\n      for (let child of node.nodes) {\n        output += stringify(child);\n      }\n    }\n    return output;\n  };\n\n  return stringify(ast);\n};\n\n/*!\n * is-number <https://github.com/jonschlinkert/is-number>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nvar isNumber$2 = function(num) {\n  if (typeof num === 'number') {\n    return num - num === 0;\n  }\n  if (typeof num === 'string' && num.trim() !== '') {\n    return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);\n  }\n  return false;\n};\n\n/*!\n * to-regex-range <https://github.com/micromatch/to-regex-range>\n *\n * Copyright (c) 2015-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nconst isNumber$1 = isNumber$2;\n\nconst toRegexRange$1 = (min, max, options) => {\n  if (isNumber$1(min) === false) {\n    throw new TypeError('toRegexRange: expected the first argument to be a number');\n  }\n\n  if (max === void 0 || min === max) {\n    return String(min);\n  }\n\n  if (isNumber$1(max) === false) {\n    throw new TypeError('toRegexRange: expected the second argument to be a number.');\n  }\n\n  let opts = { relaxZeros: true, ...options };\n  if (typeof opts.strictZeros === 'boolean') {\n    opts.relaxZeros = opts.strictZeros === false;\n  }\n\n  let relax = String(opts.relaxZeros);\n  let shorthand = String(opts.shorthand);\n  let capture = String(opts.capture);\n  let wrap = String(opts.wrap);\n  let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;\n\n  if (toRegexRange$1.cache.hasOwnProperty(cacheKey)) {\n    return toRegexRange$1.cache[cacheKey].result;\n  }\n\n  let a = Math.min(min, max);\n  let b = Math.max(min, max);\n\n  if (Math.abs(a - b) === 1) {\n    let result = min + '|' + max;\n    if (opts.capture) {\n      return `(${result})`;\n    }\n    if (opts.wrap === false) {\n      return result;\n    }\n    return `(?:${result})`;\n  }\n\n  let isPadded = hasPadding(min) || hasPadding(max);\n  let state = { min, max, a, b };\n  let positives = [];\n  let negatives = [];\n\n  if (isPadded) {\n    state.isPadded = isPadded;\n    state.maxLen = String(state.max).length;\n  }\n\n  if (a < 0) {\n    let newMin = b < 0 ? Math.abs(b) : 1;\n    negatives = splitToPatterns(newMin, Math.abs(a), state, opts);\n    a = state.a = 0;\n  }\n\n  if (b >= 0) {\n    positives = splitToPatterns(a, b, state, opts);\n  }\n\n  state.negatives = negatives;\n  state.positives = positives;\n  state.result = collatePatterns(negatives, positives);\n\n  if (opts.capture === true) {\n    state.result = `(${state.result})`;\n  } else if (opts.wrap !== false && (positives.length + negatives.length) > 1) {\n    state.result = `(?:${state.result})`;\n  }\n\n  toRegexRange$1.cache[cacheKey] = state;\n  return state.result;\n};\n\nfunction collatePatterns(neg, pos, options) {\n  let onlyNegative = filterPatterns(neg, pos, '-', false) || [];\n  let onlyPositive = filterPatterns(pos, neg, '', false) || [];\n  let intersected = filterPatterns(neg, pos, '-?', true) || [];\n  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);\n  return subpatterns.join('|');\n}\n\nfunction splitToRanges(min, max) {\n  let nines = 1;\n  let zeros = 1;\n\n  let stop = countNines(min, nines);\n  let stops = new Set([max]);\n\n  while (min <= stop && stop <= max) {\n    stops.add(stop);\n    nines += 1;\n    stop = countNines(min, nines);\n  }\n\n  stop = countZeros(max + 1, zeros) - 1;\n\n  while (min < stop && stop <= max) {\n    stops.add(stop);\n    zeros += 1;\n    stop = countZeros(max + 1, zeros) - 1;\n  }\n\n  stops = [...stops];\n  stops.sort(compare);\n  return stops;\n}\n\n/**\n * Convert a range to a regex pattern\n * @param {Number} `start`\n * @param {Number} `stop`\n * @return {String}\n */\n\nfunction rangeToPattern(start, stop, options) {\n  if (start === stop) {\n    return { pattern: start, count: [], digits: 0 };\n  }\n\n  let zipped = zip(start, stop);\n  let digits = zipped.length;\n  let pattern = '';\n  let count = 0;\n\n  for (let i = 0; i < digits; i++) {\n    let [startDigit, stopDigit] = zipped[i];\n\n    if (startDigit === stopDigit) {\n      pattern += startDigit;\n\n    } else if (startDigit !== '0' || stopDigit !== '9') {\n      pattern += toCharacterClass(startDigit, stopDigit);\n\n    } else {\n      count++;\n    }\n  }\n\n  if (count) {\n    pattern += options.shorthand === true ? '\\\\d' : '[0-9]';\n  }\n\n  return { pattern, count: [count], digits };\n}\n\nfunction splitToPatterns(min, max, tok, options) {\n  let ranges = splitToRanges(min, max);\n  let tokens = [];\n  let start = min;\n  let prev;\n\n  for (let i = 0; i < ranges.length; i++) {\n    let max = ranges[i];\n    let obj = rangeToPattern(String(start), String(max), options);\n    let zeros = '';\n\n    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {\n      if (prev.count.length > 1) {\n        prev.count.pop();\n      }\n\n      prev.count.push(obj.count[0]);\n      prev.string = prev.pattern + toQuantifier(prev.count);\n      start = max + 1;\n      continue;\n    }\n\n    if (tok.isPadded) {\n      zeros = padZeros(max, tok, options);\n    }\n\n    obj.string = zeros + obj.pattern + toQuantifier(obj.count);\n    tokens.push(obj);\n    start = max + 1;\n    prev = obj;\n  }\n\n  return tokens;\n}\n\nfunction filterPatterns(arr, comparison, prefix, intersection, options) {\n  let result = [];\n\n  for (let ele of arr) {\n    let { string } = ele;\n\n    // only push if _both_ are negative...\n    if (!intersection && !contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    }\n\n    // or _both_ are positive\n    if (intersection && contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    }\n  }\n  return result;\n}\n\n/**\n * Zip strings\n */\n\nfunction zip(a, b) {\n  let arr = [];\n  for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);\n  return arr;\n}\n\nfunction compare(a, b) {\n  return a > b ? 1 : b > a ? -1 : 0;\n}\n\nfunction contains(arr, key, val) {\n  return arr.some(ele => ele[key] === val);\n}\n\nfunction countNines(min, len) {\n  return Number(String(min).slice(0, -len) + '9'.repeat(len));\n}\n\nfunction countZeros(integer, zeros) {\n  return integer - (integer % Math.pow(10, zeros));\n}\n\nfunction toQuantifier(digits) {\n  let [start = 0, stop = ''] = digits;\n  if (stop || start > 1) {\n    return `{${start + (stop ? ',' + stop : '')}}`;\n  }\n  return '';\n}\n\nfunction toCharacterClass(a, b, options) {\n  return `[${a}${(b - a === 1) ? '' : '-'}${b}]`;\n}\n\nfunction hasPadding(str) {\n  return /^-?(0+)\\d/.test(str);\n}\n\nfunction padZeros(value, tok, options) {\n  if (!tok.isPadded) {\n    return value;\n  }\n\n  let diff = Math.abs(tok.maxLen - String(value).length);\n  let relax = options.relaxZeros !== false;\n\n  switch (diff) {\n    case 0:\n      return '';\n    case 1:\n      return relax ? '0?' : '0';\n    case 2:\n      return relax ? '0{0,2}' : '00';\n    default: {\n      return relax ? `0{0,${diff}}` : `0{${diff}}`;\n    }\n  }\n}\n\n/**\n * Cache\n */\n\ntoRegexRange$1.cache = {};\ntoRegexRange$1.clearCache = () => (toRegexRange$1.cache = {});\n\n/**\n * Expose `toRegexRange`\n */\n\nvar toRegexRange_1 = toRegexRange$1;\n\n/*!\n * fill-range <https://github.com/jonschlinkert/fill-range>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\nconst util = require$$2;\nconst toRegexRange = toRegexRange_1;\n\nconst isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\n\nconst transform = toNumber => {\n  return value => toNumber === true ? Number(value) : String(value);\n};\n\nconst isValidValue = value => {\n  return typeof value === 'number' || (typeof value === 'string' && value !== '');\n};\n\nconst isNumber = num => Number.isInteger(+num);\n\nconst zeros = input => {\n  let value = `${input}`;\n  let index = -1;\n  if (value[0] === '-') value = value.slice(1);\n  if (value === '0') return false;\n  while (value[++index] === '0');\n  return index > 0;\n};\n\nconst stringify$3 = (start, end, options) => {\n  if (typeof start === 'string' || typeof end === 'string') {\n    return true;\n  }\n  return options.stringify === true;\n};\n\nconst pad = (input, maxLength, toNumber) => {\n  if (maxLength > 0) {\n    let dash = input[0] === '-' ? '-' : '';\n    if (dash) input = input.slice(1);\n    input = (dash + input.padStart(dash ? maxLength - 1 : maxLength, '0'));\n  }\n  if (toNumber === false) {\n    return String(input);\n  }\n  return input;\n};\n\nconst toMaxLen = (input, maxLength) => {\n  let negative = input[0] === '-' ? '-' : '';\n  if (negative) {\n    input = input.slice(1);\n    maxLength--;\n  }\n  while (input.length < maxLength) input = '0' + input;\n  return negative ? ('-' + input) : input;\n};\n\nconst toSequence = (parts, options) => {\n  parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n  parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n\n  let prefix = options.capture ? '' : '?:';\n  let positives = '';\n  let negatives = '';\n  let result;\n\n  if (parts.positives.length) {\n    positives = parts.positives.join('|');\n  }\n\n  if (parts.negatives.length) {\n    negatives = `-(${prefix}${parts.negatives.join('|')})`;\n  }\n\n  if (positives && negatives) {\n    result = `${positives}|${negatives}`;\n  } else {\n    result = positives || negatives;\n  }\n\n  if (options.wrap) {\n    return `(${prefix}${result})`;\n  }\n\n  return result;\n};\n\nconst toRange = (a, b, isNumbers, options) => {\n  if (isNumbers) {\n    return toRegexRange(a, b, { wrap: false, ...options });\n  }\n\n  let start = String.fromCharCode(a);\n  if (a === b) return start;\n\n  let stop = String.fromCharCode(b);\n  return `[${start}-${stop}]`;\n};\n\nconst toRegex = (start, end, options) => {\n  if (Array.isArray(start)) {\n    let wrap = options.wrap === true;\n    let prefix = options.capture ? '' : '?:';\n    return wrap ? `(${prefix}${start.join('|')})` : start.join('|');\n  }\n  return toRegexRange(start, end, options);\n};\n\nconst rangeError = (...args) => {\n  return new RangeError('Invalid range arguments: ' + util.inspect(...args));\n};\n\nconst invalidRange = (start, end, options) => {\n  if (options.strictRanges === true) throw rangeError([start, end]);\n  return [];\n};\n\nconst invalidStep = (step, options) => {\n  if (options.strictRanges === true) {\n    throw new TypeError(`Expected step \"${step}\" to be a number`);\n  }\n  return [];\n};\n\nconst fillNumbers = (start, end, step = 1, options = {}) => {\n  let a = Number(start);\n  let b = Number(end);\n\n  if (!Number.isInteger(a) || !Number.isInteger(b)) {\n    if (options.strictRanges === true) throw rangeError([start, end]);\n    return [];\n  }\n\n  // fix negative zero\n  if (a === 0) a = 0;\n  if (b === 0) b = 0;\n\n  let descending = a > b;\n  let startString = String(start);\n  let endString = String(end);\n  let stepString = String(step);\n  step = Math.max(Math.abs(step), 1);\n\n  let padded = zeros(startString) || zeros(endString) || zeros(stepString);\n  let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;\n  let toNumber = padded === false && stringify$3(start, end, options) === false;\n  let format = options.transform || transform(toNumber);\n\n  if (options.toRegex && step === 1) {\n    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);\n  }\n\n  let parts = { negatives: [], positives: [] };\n  let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    if (options.toRegex === true && step > 1) {\n      push(a);\n    } else {\n      range.push(pad(format(a, index), maxLen, toNumber));\n    }\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return step > 1\n      ? toSequence(parts, options)\n      : toRegex(range, null, { wrap: false, ...options });\n  }\n\n  return range;\n};\n\nconst fillLetters = (start, end, step = 1, options = {}) => {\n  if ((!isNumber(start) && start.length > 1) || (!isNumber(end) && end.length > 1)) {\n    return invalidRange(start, end, options);\n  }\n\n\n  let format = options.transform || (val => String.fromCharCode(val));\n  let a = `${start}`.charCodeAt(0);\n  let b = `${end}`.charCodeAt(0);\n\n  let descending = a > b;\n  let min = Math.min(a, b);\n  let max = Math.max(a, b);\n\n  if (options.toRegex && step === 1) {\n    return toRange(min, max, false, options);\n  }\n\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    range.push(format(a, index));\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return toRegex(range, null, { wrap: false, options });\n  }\n\n  return range;\n};\n\nconst fill$2 = (start, end, step, options = {}) => {\n  if (end == null && isValidValue(start)) {\n    return [start];\n  }\n\n  if (!isValidValue(start) || !isValidValue(end)) {\n    return invalidRange(start, end, options);\n  }\n\n  if (typeof step === 'function') {\n    return fill$2(start, end, 1, { transform: step });\n  }\n\n  if (isObject(step)) {\n    return fill$2(start, end, 0, step);\n  }\n\n  let opts = { ...options };\n  if (opts.capture === true) opts.wrap = true;\n  step = step || opts.step || 1;\n\n  if (!isNumber(step)) {\n    if (step != null && !isObject(step)) return invalidStep(step, opts);\n    return fill$2(start, end, 1, step);\n  }\n\n  if (isNumber(start) && isNumber(end)) {\n    return fillNumbers(start, end, step, opts);\n  }\n\n  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);\n};\n\nvar fillRange = fill$2;\n\nconst fill$1 = fillRange;\nconst utils$1 = utils$3;\n\nconst compile$1 = (ast, options = {}) => {\n  let walk = (node, parent = {}) => {\n    let invalidBlock = utils$1.isInvalidBrace(parent);\n    let invalidNode = node.invalid === true && options.escapeInvalid === true;\n    let invalid = invalidBlock === true || invalidNode === true;\n    let prefix = options.escapeInvalid === true ? '\\\\' : '';\n    let output = '';\n\n    if (node.isOpen === true) {\n      return prefix + node.value;\n    }\n    if (node.isClose === true) {\n      return prefix + node.value;\n    }\n\n    if (node.type === 'open') {\n      return invalid ? (prefix + node.value) : '(';\n    }\n\n    if (node.type === 'close') {\n      return invalid ? (prefix + node.value) : ')';\n    }\n\n    if (node.type === 'comma') {\n      return node.prev.type === 'comma' ? '' : (invalid ? node.value : '|');\n    }\n\n    if (node.value) {\n      return node.value;\n    }\n\n    if (node.nodes && node.ranges > 0) {\n      let args = utils$1.reduce(node.nodes);\n      let range = fill$1(...args, { ...options, wrap: false, toRegex: true });\n\n      if (range.length !== 0) {\n        return args.length > 1 && range.length > 1 ? `(${range})` : range;\n      }\n    }\n\n    if (node.nodes) {\n      for (let child of node.nodes) {\n        output += walk(child, node);\n      }\n    }\n    return output;\n  };\n\n  return walk(ast);\n};\n\nvar compile_1 = compile$1;\n\nconst fill = fillRange;\nconst stringify$2 = stringify$4;\nconst utils = utils$3;\n\nconst append = (queue = '', stash = '', enclose = false) => {\n  let result = [];\n\n  queue = [].concat(queue);\n  stash = [].concat(stash);\n\n  if (!stash.length) return queue;\n  if (!queue.length) {\n    return enclose ? utils.flatten(stash).map(ele => `{${ele}}`) : stash;\n  }\n\n  for (let item of queue) {\n    if (Array.isArray(item)) {\n      for (let value of item) {\n        result.push(append(value, stash, enclose));\n      }\n    } else {\n      for (let ele of stash) {\n        if (enclose === true && typeof ele === 'string') ele = `{${ele}}`;\n        result.push(Array.isArray(ele) ? append(item, ele, enclose) : (item + ele));\n      }\n    }\n  }\n  return utils.flatten(result);\n};\n\nconst expand$1 = (ast, options = {}) => {\n  let rangeLimit = options.rangeLimit === void 0 ? 1000 : options.rangeLimit;\n\n  let walk = (node, parent = {}) => {\n    node.queue = [];\n\n    let p = parent;\n    let q = parent.queue;\n\n    while (p.type !== 'brace' && p.type !== 'root' && p.parent) {\n      p = p.parent;\n      q = p.queue;\n    }\n\n    if (node.invalid || node.dollar) {\n      q.push(append(q.pop(), stringify$2(node, options)));\n      return;\n    }\n\n    if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {\n      q.push(append(q.pop(), ['{}']));\n      return;\n    }\n\n    if (node.nodes && node.ranges > 0) {\n      let args = utils.reduce(node.nodes);\n\n      if (utils.exceedsLimit(...args, options.step, rangeLimit)) {\n        throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');\n      }\n\n      let range = fill(...args, options);\n      if (range.length === 0) {\n        range = stringify$2(node, options);\n      }\n\n      q.push(append(q.pop(), range));\n      node.nodes = [];\n      return;\n    }\n\n    let enclose = utils.encloseBrace(node);\n    let queue = node.queue;\n    let block = node;\n\n    while (block.type !== 'brace' && block.type !== 'root' && block.parent) {\n      block = block.parent;\n      queue = block.queue;\n    }\n\n    for (let i = 0; i < node.nodes.length; i++) {\n      let child = node.nodes[i];\n\n      if (child.type === 'comma' && node.type === 'brace') {\n        if (i === 1) queue.push('');\n        queue.push('');\n        continue;\n      }\n\n      if (child.type === 'close') {\n        q.push(append(q.pop(), queue, enclose));\n        continue;\n      }\n\n      if (child.value && child.type !== 'open') {\n        queue.push(append(queue.pop(), child.value));\n        continue;\n      }\n\n      if (child.nodes) {\n        walk(child, node);\n      }\n    }\n\n    return queue;\n  };\n\n  return utils.flatten(walk(ast));\n};\n\nvar expand_1 = expand$1;\n\nvar constants$1 = {\n  MAX_LENGTH: 1024 * 64,\n\n  // Digits\n  CHAR_0: '0', /* 0 */\n  CHAR_9: '9', /* 9 */\n\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 'A', /* A */\n  CHAR_LOWERCASE_A: 'a', /* a */\n  CHAR_UPPERCASE_Z: 'Z', /* Z */\n  CHAR_LOWERCASE_Z: 'z', /* z */\n\n  CHAR_LEFT_PARENTHESES: '(', /* ( */\n  CHAR_RIGHT_PARENTHESES: ')', /* ) */\n\n  CHAR_ASTERISK: '*', /* * */\n\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: '&', /* & */\n  CHAR_AT: '@', /* @ */\n  CHAR_BACKSLASH: '\\\\', /* \\ */\n  CHAR_BACKTICK: '`', /* ` */\n  CHAR_CARRIAGE_RETURN: '\\r', /* \\r */\n  CHAR_CIRCUMFLEX_ACCENT: '^', /* ^ */\n  CHAR_COLON: ':', /* : */\n  CHAR_COMMA: ',', /* , */\n  CHAR_DOLLAR: '$', /* . */\n  CHAR_DOT: '.', /* . */\n  CHAR_DOUBLE_QUOTE: '\"', /* \" */\n  CHAR_EQUAL: '=', /* = */\n  CHAR_EXCLAMATION_MARK: '!', /* ! */\n  CHAR_FORM_FEED: '\\f', /* \\f */\n  CHAR_FORWARD_SLASH: '/', /* / */\n  CHAR_HASH: '#', /* # */\n  CHAR_HYPHEN_MINUS: '-', /* - */\n  CHAR_LEFT_ANGLE_BRACKET: '<', /* < */\n  CHAR_LEFT_CURLY_BRACE: '{', /* { */\n  CHAR_LEFT_SQUARE_BRACKET: '[', /* [ */\n  CHAR_LINE_FEED: '\\n', /* \\n */\n  CHAR_NO_BREAK_SPACE: '\\u00A0', /* \\u00A0 */\n  CHAR_PERCENT: '%', /* % */\n  CHAR_PLUS: '+', /* + */\n  CHAR_QUESTION_MARK: '?', /* ? */\n  CHAR_RIGHT_ANGLE_BRACKET: '>', /* > */\n  CHAR_RIGHT_CURLY_BRACE: '}', /* } */\n  CHAR_RIGHT_SQUARE_BRACKET: ']', /* ] */\n  CHAR_SEMICOLON: ';', /* ; */\n  CHAR_SINGLE_QUOTE: '\\'', /* ' */\n  CHAR_SPACE: ' ', /*   */\n  CHAR_TAB: '\\t', /* \\t */\n  CHAR_UNDERSCORE: '_', /* _ */\n  CHAR_VERTICAL_LINE: '|', /* | */\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\\uFEFF' /* \\uFEFF */\n};\n\nconst stringify$1 = stringify$4;\n\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  CHAR_BACKSLASH, /* \\ */\n  CHAR_BACKTICK, /* ` */\n  CHAR_COMMA, /* , */\n  CHAR_DOT, /* . */\n  CHAR_LEFT_PARENTHESES, /* ( */\n  CHAR_RIGHT_PARENTHESES, /* ) */\n  CHAR_LEFT_CURLY_BRACE, /* { */\n  CHAR_RIGHT_CURLY_BRACE, /* } */\n  CHAR_LEFT_SQUARE_BRACKET, /* [ */\n  CHAR_RIGHT_SQUARE_BRACKET, /* ] */\n  CHAR_DOUBLE_QUOTE, /* \" */\n  CHAR_SINGLE_QUOTE, /* ' */\n  CHAR_NO_BREAK_SPACE,\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE\n} = constants$1;\n\n/**\n * parse\n */\n\nconst parse$1 = (input, options = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  let opts = options || {};\n  let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  if (input.length > max) {\n    throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);\n  }\n\n  let ast = { type: 'root', input, nodes: [] };\n  let stack = [ast];\n  let block = ast;\n  let prev = ast;\n  let brackets = 0;\n  let length = input.length;\n  let index = 0;\n  let depth = 0;\n  let value;\n\n  /**\n   * Helpers\n   */\n\n  const advance = () => input[index++];\n  const push = node => {\n    if (node.type === 'text' && prev.type === 'dot') {\n      prev.type = 'text';\n    }\n\n    if (prev && prev.type === 'text' && node.type === 'text') {\n      prev.value += node.value;\n      return;\n    }\n\n    block.nodes.push(node);\n    node.parent = block;\n    node.prev = prev;\n    prev = node;\n    return node;\n  };\n\n  push({ type: 'bos' });\n\n  while (index < length) {\n    block = stack[stack.length - 1];\n    value = advance();\n\n    /**\n     * Invalid chars\n     */\n\n    if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {\n      continue;\n    }\n\n    /**\n     * Escaped chars\n     */\n\n    if (value === CHAR_BACKSLASH) {\n      push({ type: 'text', value: (options.keepEscaping ? value : '') + advance() });\n      continue;\n    }\n\n    /**\n     * Right square bracket (literal): ']'\n     */\n\n    if (value === CHAR_RIGHT_SQUARE_BRACKET) {\n      push({ type: 'text', value: '\\\\' + value });\n      continue;\n    }\n\n    /**\n     * Left square bracket: '['\n     */\n\n    if (value === CHAR_LEFT_SQUARE_BRACKET) {\n      brackets++;\n      let next;\n\n      while (index < length && (next = advance())) {\n        value += next;\n\n        if (next === CHAR_LEFT_SQUARE_BRACKET) {\n          brackets++;\n          continue;\n        }\n\n        if (next === CHAR_BACKSLASH) {\n          value += advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          brackets--;\n\n          if (brackets === 0) {\n            break;\n          }\n        }\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === CHAR_LEFT_PARENTHESES) {\n      block = push({ type: 'paren', nodes: [] });\n      stack.push(block);\n      push({ type: 'text', value });\n      continue;\n    }\n\n    if (value === CHAR_RIGHT_PARENTHESES) {\n      if (block.type !== 'paren') {\n        push({ type: 'text', value });\n        continue;\n      }\n      block = stack.pop();\n      push({ type: 'text', value });\n      block = stack[stack.length - 1];\n      continue;\n    }\n\n    /**\n     * Quotes: '|\"|`\n     */\n\n    if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {\n      let open = value;\n      let next;\n\n      if (options.keepQuotes !== true) {\n        value = '';\n      }\n\n      while (index < length && (next = advance())) {\n        if (next === CHAR_BACKSLASH) {\n          value += next + advance();\n          continue;\n        }\n\n        if (next === open) {\n          if (options.keepQuotes === true) value += next;\n          break;\n        }\n\n        value += next;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Left curly brace: '{'\n     */\n\n    if (value === CHAR_LEFT_CURLY_BRACE) {\n      depth++;\n\n      let dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;\n      let brace = {\n        type: 'brace',\n        open: true,\n        close: false,\n        dollar,\n        depth,\n        commas: 0,\n        ranges: 0,\n        nodes: []\n      };\n\n      block = push(brace);\n      stack.push(block);\n      push({ type: 'open', value });\n      continue;\n    }\n\n    /**\n     * Right curly brace: '}'\n     */\n\n    if (value === CHAR_RIGHT_CURLY_BRACE) {\n      if (block.type !== 'brace') {\n        push({ type: 'text', value });\n        continue;\n      }\n\n      let type = 'close';\n      block = stack.pop();\n      block.close = true;\n\n      push({ type, value });\n      depth--;\n\n      block = stack[stack.length - 1];\n      continue;\n    }\n\n    /**\n     * Comma: ','\n     */\n\n    if (value === CHAR_COMMA && depth > 0) {\n      if (block.ranges > 0) {\n        block.ranges = 0;\n        let open = block.nodes.shift();\n        block.nodes = [open, { type: 'text', value: stringify$1(block) }];\n      }\n\n      push({ type: 'comma', value });\n      block.commas++;\n      continue;\n    }\n\n    /**\n     * Dot: '.'\n     */\n\n    if (value === CHAR_DOT && depth > 0 && block.commas === 0) {\n      let siblings = block.nodes;\n\n      if (depth === 0 || siblings.length === 0) {\n        push({ type: 'text', value });\n        continue;\n      }\n\n      if (prev.type === 'dot') {\n        block.range = [];\n        prev.value += value;\n        prev.type = 'range';\n\n        if (block.nodes.length !== 3 && block.nodes.length !== 5) {\n          block.invalid = true;\n          block.ranges = 0;\n          prev.type = 'text';\n          continue;\n        }\n\n        block.ranges++;\n        block.args = [];\n        continue;\n      }\n\n      if (prev.type === 'range') {\n        siblings.pop();\n\n        let before = siblings[siblings.length - 1];\n        before.value += prev.value + value;\n        prev = before;\n        block.ranges--;\n        continue;\n      }\n\n      push({ type: 'dot', value });\n      continue;\n    }\n\n    /**\n     * Text\n     */\n\n    push({ type: 'text', value });\n  }\n\n  // Mark imbalanced braces and brackets as invalid\n  do {\n    block = stack.pop();\n\n    if (block.type !== 'root') {\n      block.nodes.forEach(node => {\n        if (!node.nodes) {\n          if (node.type === 'open') node.isOpen = true;\n          if (node.type === 'close') node.isClose = true;\n          if (!node.nodes) node.type = 'text';\n          node.invalid = true;\n        }\n      });\n\n      // get the location of the block on parent.nodes (block's siblings)\n      let parent = stack[stack.length - 1];\n      let index = parent.nodes.indexOf(block);\n      // replace the (invalid) block with it's nodes\n      parent.nodes.splice(index, 1, ...block.nodes);\n    }\n  } while (stack.length > 0);\n\n  push({ type: 'eos' });\n  return ast;\n};\n\nvar parse_1 = parse$1;\n\nconst stringify = stringify$4;\nconst compile = compile_1;\nconst expand = expand_1;\nconst parse = parse_1;\n\n/**\n * Expand the given pattern or create a regex-compatible string.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']\n * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {String}\n * @api public\n */\n\nconst braces$1 = (input, options = {}) => {\n  let output = [];\n\n  if (Array.isArray(input)) {\n    for (let pattern of input) {\n      let result = braces$1.create(pattern, options);\n      if (Array.isArray(result)) {\n        output.push(...result);\n      } else {\n        output.push(result);\n      }\n    }\n  } else {\n    output = [].concat(braces$1.create(input, options));\n  }\n\n  if (options && options.expand === true && options.nodupes === true) {\n    output = [...new Set(output)];\n  }\n  return output;\n};\n\n/**\n * Parse the given `str` with the given `options`.\n *\n * ```js\n * // braces.parse(pattern, [, options]);\n * const ast = braces.parse('a/{b,c}/d');\n * console.log(ast);\n * ```\n * @param {String} pattern Brace pattern to parse\n * @param {Object} options\n * @return {Object} Returns an AST\n * @api public\n */\n\nbraces$1.parse = (input, options = {}) => parse(input, options);\n\n/**\n * Creates a braces string from an AST, or an AST node.\n *\n * ```js\n * const braces = require('braces');\n * let ast = braces.parse('foo/{a,b}/bar');\n * console.log(stringify(ast.nodes[2])); //=> '{a,b}'\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces$1.stringify = (input, options = {}) => {\n  if (typeof input === 'string') {\n    return stringify(braces$1.parse(input, options), options);\n  }\n  return stringify(input, options);\n};\n\n/**\n * Compiles a brace pattern into a regex-compatible, optimized string.\n * This method is called by the main [braces](#braces) function by default.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.compile('a/{b,c}/d'));\n * //=> ['a/(b|c)/d']\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces$1.compile = (input, options = {}) => {\n  if (typeof input === 'string') {\n    input = braces$1.parse(input, options);\n  }\n  return compile(input, options);\n};\n\n/**\n * Expands a brace pattern into an array. This method is called by the\n * main [braces](#braces) function when `options.expand` is true. Before\n * using this method it's recommended that you read the [performance notes](#performance))\n * and advantages of using [.compile](#compile) instead.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.expand('a/{b,c}/d'));\n * //=> ['a/b/d', 'a/c/d'];\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces$1.expand = (input, options = {}) => {\n  if (typeof input === 'string') {\n    input = braces$1.parse(input, options);\n  }\n\n  let result = expand(input, options);\n\n  // filter out empty strings if specified\n  if (options.noempty === true) {\n    result = result.filter(Boolean);\n  }\n\n  // filter out duplicates if specified\n  if (options.nodupes === true) {\n    result = [...new Set(result)];\n  }\n\n  return result;\n};\n\n/**\n * Processes a brace pattern and returns either an expanded array\n * (if `options.expand` is true), a highly optimized regex-compatible string.\n * This method is called by the main [braces](#braces) function.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))\n * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces$1.create = (input, options = {}) => {\n  if (input === '' || input.length < 3) {\n    return [input];\n  }\n\n return options.expand !== true\n    ? braces$1.compile(input, options)\n    : braces$1.expand(input, options);\n};\n\n/**\n * Expose \"braces\"\n */\n\nvar braces_1 = braces$1;\n\nvar binaryExtensionsExports = {};\nvar binaryExtensions$1 = {\n  get exports(){ return binaryExtensionsExports; },\n  set exports(v){ binaryExtensionsExports = v; },\n};\n\nconst require$$0 = [\n\t\"3dm\",\n\t\"3ds\",\n\t\"3g2\",\n\t\"3gp\",\n\t\"7z\",\n\t\"a\",\n\t\"aac\",\n\t\"adp\",\n\t\"ai\",\n\t\"aif\",\n\t\"aiff\",\n\t\"alz\",\n\t\"ape\",\n\t\"apk\",\n\t\"appimage\",\n\t\"ar\",\n\t\"arj\",\n\t\"asf\",\n\t\"au\",\n\t\"avi\",\n\t\"bak\",\n\t\"baml\",\n\t\"bh\",\n\t\"bin\",\n\t\"bk\",\n\t\"bmp\",\n\t\"btif\",\n\t\"bz2\",\n\t\"bzip2\",\n\t\"cab\",\n\t\"caf\",\n\t\"cgm\",\n\t\"class\",\n\t\"cmx\",\n\t\"cpio\",\n\t\"cr2\",\n\t\"cur\",\n\t\"dat\",\n\t\"dcm\",\n\t\"deb\",\n\t\"dex\",\n\t\"djvu\",\n\t\"dll\",\n\t\"dmg\",\n\t\"dng\",\n\t\"doc\",\n\t\"docm\",\n\t\"docx\",\n\t\"dot\",\n\t\"dotm\",\n\t\"dra\",\n\t\"DS_Store\",\n\t\"dsk\",\n\t\"dts\",\n\t\"dtshd\",\n\t\"dvb\",\n\t\"dwg\",\n\t\"dxf\",\n\t\"ecelp4800\",\n\t\"ecelp7470\",\n\t\"ecelp9600\",\n\t\"egg\",\n\t\"eol\",\n\t\"eot\",\n\t\"epub\",\n\t\"exe\",\n\t\"f4v\",\n\t\"fbs\",\n\t\"fh\",\n\t\"fla\",\n\t\"flac\",\n\t\"flatpak\",\n\t\"fli\",\n\t\"flv\",\n\t\"fpx\",\n\t\"fst\",\n\t\"fvt\",\n\t\"g3\",\n\t\"gh\",\n\t\"gif\",\n\t\"graffle\",\n\t\"gz\",\n\t\"gzip\",\n\t\"h261\",\n\t\"h263\",\n\t\"h264\",\n\t\"icns\",\n\t\"ico\",\n\t\"ief\",\n\t\"img\",\n\t\"ipa\",\n\t\"iso\",\n\t\"jar\",\n\t\"jpeg\",\n\t\"jpg\",\n\t\"jpgv\",\n\t\"jpm\",\n\t\"jxr\",\n\t\"key\",\n\t\"ktx\",\n\t\"lha\",\n\t\"lib\",\n\t\"lvp\",\n\t\"lz\",\n\t\"lzh\",\n\t\"lzma\",\n\t\"lzo\",\n\t\"m3u\",\n\t\"m4a\",\n\t\"m4v\",\n\t\"mar\",\n\t\"mdi\",\n\t\"mht\",\n\t\"mid\",\n\t\"midi\",\n\t\"mj2\",\n\t\"mka\",\n\t\"mkv\",\n\t\"mmr\",\n\t\"mng\",\n\t\"mobi\",\n\t\"mov\",\n\t\"movie\",\n\t\"mp3\",\n\t\"mp4\",\n\t\"mp4a\",\n\t\"mpeg\",\n\t\"mpg\",\n\t\"mpga\",\n\t\"mxu\",\n\t\"nef\",\n\t\"npx\",\n\t\"numbers\",\n\t\"nupkg\",\n\t\"o\",\n\t\"odp\",\n\t\"ods\",\n\t\"odt\",\n\t\"oga\",\n\t\"ogg\",\n\t\"ogv\",\n\t\"otf\",\n\t\"ott\",\n\t\"pages\",\n\t\"pbm\",\n\t\"pcx\",\n\t\"pdb\",\n\t\"pdf\",\n\t\"pea\",\n\t\"pgm\",\n\t\"pic\",\n\t\"png\",\n\t\"pnm\",\n\t\"pot\",\n\t\"potm\",\n\t\"potx\",\n\t\"ppa\",\n\t\"ppam\",\n\t\"ppm\",\n\t\"pps\",\n\t\"ppsm\",\n\t\"ppsx\",\n\t\"ppt\",\n\t\"pptm\",\n\t\"pptx\",\n\t\"psd\",\n\t\"pya\",\n\t\"pyc\",\n\t\"pyo\",\n\t\"pyv\",\n\t\"qt\",\n\t\"rar\",\n\t\"ras\",\n\t\"raw\",\n\t\"resources\",\n\t\"rgb\",\n\t\"rip\",\n\t\"rlc\",\n\t\"rmf\",\n\t\"rmvb\",\n\t\"rpm\",\n\t\"rtf\",\n\t\"rz\",\n\t\"s3m\",\n\t\"s7z\",\n\t\"scpt\",\n\t\"sgi\",\n\t\"shar\",\n\t\"snap\",\n\t\"sil\",\n\t\"sketch\",\n\t\"slk\",\n\t\"smv\",\n\t\"snk\",\n\t\"so\",\n\t\"stl\",\n\t\"suo\",\n\t\"sub\",\n\t\"swf\",\n\t\"tar\",\n\t\"tbz\",\n\t\"tbz2\",\n\t\"tga\",\n\t\"tgz\",\n\t\"thmx\",\n\t\"tif\",\n\t\"tiff\",\n\t\"tlz\",\n\t\"ttc\",\n\t\"ttf\",\n\t\"txz\",\n\t\"udf\",\n\t\"uvh\",\n\t\"uvi\",\n\t\"uvm\",\n\t\"uvp\",\n\t\"uvs\",\n\t\"uvu\",\n\t\"viv\",\n\t\"vob\",\n\t\"war\",\n\t\"wav\",\n\t\"wax\",\n\t\"wbmp\",\n\t\"wdp\",\n\t\"weba\",\n\t\"webm\",\n\t\"webp\",\n\t\"whl\",\n\t\"wim\",\n\t\"wm\",\n\t\"wma\",\n\t\"wmv\",\n\t\"wmx\",\n\t\"woff\",\n\t\"woff2\",\n\t\"wrm\",\n\t\"wvx\",\n\t\"xbm\",\n\t\"xif\",\n\t\"xla\",\n\t\"xlam\",\n\t\"xls\",\n\t\"xlsb\",\n\t\"xlsm\",\n\t\"xlsx\",\n\t\"xlt\",\n\t\"xltm\",\n\t\"xltx\",\n\t\"xm\",\n\t\"xmind\",\n\t\"xpi\",\n\t\"xpm\",\n\t\"xwd\",\n\t\"xz\",\n\t\"z\",\n\t\"zip\",\n\t\"zipx\"\n];\n\n(function (module) {\n\tmodule.exports = require$$0;\n} (binaryExtensions$1));\n\nconst path = require$$0$2;\nconst binaryExtensions = binaryExtensionsExports;\n\nconst extensions = new Set(binaryExtensions);\n\nvar isBinaryPath$1 = filePath => extensions.has(path.extname(filePath).slice(1).toLowerCase());\n\nvar constants = {};\n\n(function (exports) {\n\n\tconst {sep} = require$$0$2;\n\tconst {platform} = process;\n\tconst os = require$$2$1;\n\n\texports.EV_ALL = 'all';\n\texports.EV_READY = 'ready';\n\texports.EV_ADD = 'add';\n\texports.EV_CHANGE = 'change';\n\texports.EV_ADD_DIR = 'addDir';\n\texports.EV_UNLINK = 'unlink';\n\texports.EV_UNLINK_DIR = 'unlinkDir';\n\texports.EV_RAW = 'raw';\n\texports.EV_ERROR = 'error';\n\n\texports.STR_DATA = 'data';\n\texports.STR_END = 'end';\n\texports.STR_CLOSE = 'close';\n\n\texports.FSEVENT_CREATED = 'created';\n\texports.FSEVENT_MODIFIED = 'modified';\n\texports.FSEVENT_DELETED = 'deleted';\n\texports.FSEVENT_MOVED = 'moved';\n\texports.FSEVENT_CLONED = 'cloned';\n\texports.FSEVENT_UNKNOWN = 'unknown';\n\texports.FSEVENT_TYPE_FILE = 'file';\n\texports.FSEVENT_TYPE_DIRECTORY = 'directory';\n\texports.FSEVENT_TYPE_SYMLINK = 'symlink';\n\n\texports.KEY_LISTENERS = 'listeners';\n\texports.KEY_ERR = 'errHandlers';\n\texports.KEY_RAW = 'rawEmitters';\n\texports.HANDLER_KEYS = [exports.KEY_LISTENERS, exports.KEY_ERR, exports.KEY_RAW];\n\n\texports.DOT_SLASH = `.${sep}`;\n\n\texports.BACK_SLASH_RE = /\\\\/g;\n\texports.DOUBLE_SLASH_RE = /\\/\\//;\n\texports.SLASH_OR_BACK_SLASH_RE = /[/\\\\]/;\n\texports.DOT_RE = /\\..*\\.(sw[px])$|~$|\\.subl.*\\.tmp/;\n\texports.REPLACER_RE = /^\\.[/\\\\]/;\n\n\texports.SLASH = '/';\n\texports.SLASH_SLASH = '//';\n\texports.BRACE_START = '{';\n\texports.BANG = '!';\n\texports.ONE_DOT = '.';\n\texports.TWO_DOTS = '..';\n\texports.STAR = '*';\n\texports.GLOBSTAR = '**';\n\texports.ROOT_GLOBSTAR = '/**/*';\n\texports.SLASH_GLOBSTAR = '/**';\n\texports.DIR_SUFFIX = 'Dir';\n\texports.ANYMATCH_OPTS = {dot: true};\n\texports.STRING_TYPE = 'string';\n\texports.FUNCTION_TYPE = 'function';\n\texports.EMPTY_STR = '';\n\texports.EMPTY_FN = () => {};\n\texports.IDENTITY_FN = val => val;\n\n\texports.isWindows = platform === 'win32';\n\texports.isMacos = platform === 'darwin';\n\texports.isLinux = platform === 'linux';\n\texports.isIBMi = os.type() === 'OS400';\n} (constants));\n\nconst fs$2 = require$$0$1;\nconst sysPath$2 = require$$0$2;\nconst { promisify: promisify$2 } = require$$2;\nconst isBinaryPath = isBinaryPath$1;\nconst {\n  isWindows: isWindows$1,\n  isLinux,\n  EMPTY_FN: EMPTY_FN$2,\n  EMPTY_STR: EMPTY_STR$1,\n  KEY_LISTENERS,\n  KEY_ERR,\n  KEY_RAW,\n  HANDLER_KEYS,\n  EV_CHANGE: EV_CHANGE$2,\n  EV_ADD: EV_ADD$2,\n  EV_ADD_DIR: EV_ADD_DIR$2,\n  EV_ERROR: EV_ERROR$2,\n  STR_DATA: STR_DATA$1,\n  STR_END: STR_END$2,\n  BRACE_START: BRACE_START$1,\n  STAR\n} = constants;\n\nconst THROTTLE_MODE_WATCH = 'watch';\n\nconst open = promisify$2(fs$2.open);\nconst stat$2 = promisify$2(fs$2.stat);\nconst lstat$1 = promisify$2(fs$2.lstat);\nconst close = promisify$2(fs$2.close);\nconst fsrealpath = promisify$2(fs$2.realpath);\n\nconst statMethods$1 = { lstat: lstat$1, stat: stat$2 };\n\n// TODO: emit errors properly. Example: EMFILE on Macos.\nconst foreach = (val, fn) => {\n  if (val instanceof Set) {\n    val.forEach(fn);\n  } else {\n    fn(val);\n  }\n};\n\nconst addAndConvert = (main, prop, item) => {\n  let container = main[prop];\n  if (!(container instanceof Set)) {\n    main[prop] = container = new Set([container]);\n  }\n  container.add(item);\n};\n\nconst clearItem = cont => key => {\n  const set = cont[key];\n  if (set instanceof Set) {\n    set.clear();\n  } else {\n    delete cont[key];\n  }\n};\n\nconst delFromSet = (main, prop, item) => {\n  const container = main[prop];\n  if (container instanceof Set) {\n    container.delete(item);\n  } else if (container === item) {\n    delete main[prop];\n  }\n};\n\nconst isEmptySet = (val) => val instanceof Set ? val.size === 0 : !val;\n\n/**\n * @typedef {String} Path\n */\n\n// fs_watch helpers\n\n// object to hold per-process fs_watch instances\n// (may be shared across chokidar FSWatcher instances)\n\n/**\n * @typedef {Object} FsWatchContainer\n * @property {Set} listeners\n * @property {Set} errHandlers\n * @property {Set} rawEmitters\n * @property {fs.FSWatcher=} watcher\n * @property {Boolean=} watcherUnusable\n */\n\n/**\n * @type {Map<String,FsWatchContainer>}\n */\nconst FsWatchInstances = new Map();\n\n/**\n * Instantiates the fs_watch interface\n * @param {String} path to be watched\n * @param {Object} options to be passed to fs_watch\n * @param {Function} listener main event handler\n * @param {Function} errHandler emits info about errors\n * @param {Function} emitRaw emits raw event data\n * @returns {fs.FSWatcher} new fsevents instance\n */\nfunction createFsWatchInstance(path, options, listener, errHandler, emitRaw) {\n  const handleEvent = (rawEvent, evPath) => {\n    listener(path);\n    emitRaw(rawEvent, evPath, {watchedPath: path});\n\n    // emit based on events occurring for files from a directory's watcher in\n    // case the file's watcher misses it (and rely on throttling to de-dupe)\n    if (evPath && path !== evPath) {\n      fsWatchBroadcast(\n        sysPath$2.resolve(path, evPath), KEY_LISTENERS, sysPath$2.join(path, evPath)\n      );\n    }\n  };\n  try {\n    return fs$2.watch(path, options, handleEvent);\n  } catch (error) {\n    errHandler(error);\n  }\n}\n\n/**\n * Helper for passing fs_watch event data to a collection of listeners\n * @param {Path} fullPath absolute path bound to fs_watch instance\n * @param {String} type listener type\n * @param {*=} val1 arguments to be passed to listeners\n * @param {*=} val2\n * @param {*=} val3\n */\nconst fsWatchBroadcast = (fullPath, type, val1, val2, val3) => {\n  const cont = FsWatchInstances.get(fullPath);\n  if (!cont) return;\n  foreach(cont[type], (listener) => {\n    listener(val1, val2, val3);\n  });\n};\n\n/**\n * Instantiates the fs_watch interface or binds listeners\n * to an existing one covering the same file system entry\n * @param {String} path\n * @param {String} fullPath absolute path\n * @param {Object} options to be passed to fs_watch\n * @param {Object} handlers container for event listener functions\n */\nconst setFsWatchListener = (path, fullPath, options, handlers) => {\n  const {listener, errHandler, rawEmitter} = handlers;\n  let cont = FsWatchInstances.get(fullPath);\n\n  /** @type {fs.FSWatcher=} */\n  let watcher;\n  if (!options.persistent) {\n    watcher = createFsWatchInstance(\n      path, options, listener, errHandler, rawEmitter\n    );\n    return watcher.close.bind(watcher);\n  }\n  if (cont) {\n    addAndConvert(cont, KEY_LISTENERS, listener);\n    addAndConvert(cont, KEY_ERR, errHandler);\n    addAndConvert(cont, KEY_RAW, rawEmitter);\n  } else {\n    watcher = createFsWatchInstance(\n      path,\n      options,\n      fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS),\n      errHandler, // no need to use broadcast here\n      fsWatchBroadcast.bind(null, fullPath, KEY_RAW)\n    );\n    if (!watcher) return;\n    watcher.on(EV_ERROR$2, async (error) => {\n      const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);\n      cont.watcherUnusable = true; // documented since Node 10.4.1\n      // Workaround for https://github.com/joyent/node/issues/4337\n      if (isWindows$1 && error.code === 'EPERM') {\n        try {\n          const fd = await open(path, 'r');\n          await close(fd);\n          broadcastErr(error);\n        } catch (err) {}\n      } else {\n        broadcastErr(error);\n      }\n    });\n    cont = {\n      listeners: listener,\n      errHandlers: errHandler,\n      rawEmitters: rawEmitter,\n      watcher\n    };\n    FsWatchInstances.set(fullPath, cont);\n  }\n  // const index = cont.listeners.indexOf(listener);\n\n  // removes this instance's listeners and closes the underlying fs_watch\n  // instance if there are no more listeners left\n  return () => {\n    delFromSet(cont, KEY_LISTENERS, listener);\n    delFromSet(cont, KEY_ERR, errHandler);\n    delFromSet(cont, KEY_RAW, rawEmitter);\n    if (isEmptySet(cont.listeners)) {\n      // Check to protect against issue gh-730.\n      // if (cont.watcherUnusable) {\n      cont.watcher.close();\n      // }\n      FsWatchInstances.delete(fullPath);\n      HANDLER_KEYS.forEach(clearItem(cont));\n      cont.watcher = undefined;\n      Object.freeze(cont);\n    }\n  };\n};\n\n// fs_watchFile helpers\n\n// object to hold per-process fs_watchFile instances\n// (may be shared across chokidar FSWatcher instances)\nconst FsWatchFileInstances = new Map();\n\n/**\n * Instantiates the fs_watchFile interface or binds listeners\n * to an existing one covering the same file system entry\n * @param {String} path to be watched\n * @param {String} fullPath absolute path\n * @param {Object} options options to be passed to fs_watchFile\n * @param {Object} handlers container for event listener functions\n * @returns {Function} closer\n */\nconst setFsWatchFileListener = (path, fullPath, options, handlers) => {\n  const {listener, rawEmitter} = handlers;\n  let cont = FsWatchFileInstances.get(fullPath);\n\n  const copts = cont && cont.options;\n  if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {\n    fs$2.unwatchFile(fullPath);\n    cont = undefined;\n  }\n\n  /* eslint-enable no-unused-vars, prefer-destructuring */\n\n  if (cont) {\n    addAndConvert(cont, KEY_LISTENERS, listener);\n    addAndConvert(cont, KEY_RAW, rawEmitter);\n  } else {\n    // TODO\n    // listeners.add(listener);\n    // rawEmitters.add(rawEmitter);\n    cont = {\n      listeners: listener,\n      rawEmitters: rawEmitter,\n      options,\n      watcher: fs$2.watchFile(fullPath, options, (curr, prev) => {\n        foreach(cont.rawEmitters, (rawEmitter) => {\n          rawEmitter(EV_CHANGE$2, fullPath, {curr, prev});\n        });\n        const currmtime = curr.mtimeMs;\n        if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {\n          foreach(cont.listeners, (listener) => listener(path, curr));\n        }\n      })\n    };\n    FsWatchFileInstances.set(fullPath, cont);\n  }\n  // const index = cont.listeners.indexOf(listener);\n\n  // Removes this instance's listeners and closes the underlying fs_watchFile\n  // instance if there are no more listeners left.\n  return () => {\n    delFromSet(cont, KEY_LISTENERS, listener);\n    delFromSet(cont, KEY_RAW, rawEmitter);\n    if (isEmptySet(cont.listeners)) {\n      FsWatchFileInstances.delete(fullPath);\n      fs$2.unwatchFile(fullPath);\n      cont.options = cont.watcher = undefined;\n      Object.freeze(cont);\n    }\n  };\n};\n\n/**\n * @mixin\n */\nlet NodeFsHandler$1 = class NodeFsHandler {\n\n/**\n * @param {import(\"../index\").FSWatcher} fsW\n */\nconstructor(fsW) {\n  this.fsw = fsW;\n  this._boundHandleError = (error) => fsW._handleError(error);\n}\n\n/**\n * Watch file for changes with fs_watchFile or fs_watch.\n * @param {String} path to file or dir\n * @param {Function} listener on fs change\n * @returns {Function} closer for the watcher instance\n */\n_watchWithNodeFs(path, listener) {\n  const opts = this.fsw.options;\n  const directory = sysPath$2.dirname(path);\n  const basename = sysPath$2.basename(path);\n  const parent = this.fsw._getWatchedDir(directory);\n  parent.add(basename);\n  const absolutePath = sysPath$2.resolve(path);\n  const options = {persistent: opts.persistent};\n  if (!listener) listener = EMPTY_FN$2;\n\n  let closer;\n  if (opts.usePolling) {\n    options.interval = opts.enableBinaryInterval && isBinaryPath(basename) ?\n      opts.binaryInterval : opts.interval;\n    closer = setFsWatchFileListener(path, absolutePath, options, {\n      listener,\n      rawEmitter: this.fsw._emitRaw\n    });\n  } else {\n    closer = setFsWatchListener(path, absolutePath, options, {\n      listener,\n      errHandler: this._boundHandleError,\n      rawEmitter: this.fsw._emitRaw\n    });\n  }\n  return closer;\n}\n\n/**\n * Watch a file and emit add event if warranted.\n * @param {Path} file Path\n * @param {fs.Stats} stats result of fs_stat\n * @param {Boolean} initialAdd was the file added at watch instantiation?\n * @returns {Function} closer for the watcher instance\n */\n_handleFile(file, stats, initialAdd) {\n  if (this.fsw.closed) {\n    return;\n  }\n  const dirname = sysPath$2.dirname(file);\n  const basename = sysPath$2.basename(file);\n  const parent = this.fsw._getWatchedDir(dirname);\n  // stats is always present\n  let prevStats = stats;\n\n  // if the file is already being watched, do nothing\n  if (parent.has(basename)) return;\n\n  const listener = async (path, newStats) => {\n    if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5)) return;\n    if (!newStats || newStats.mtimeMs === 0) {\n      try {\n        const newStats = await stat$2(file);\n        if (this.fsw.closed) return;\n        // Check that change event was not fired because of changed only accessTime.\n        const at = newStats.atimeMs;\n        const mt = newStats.mtimeMs;\n        if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n          this.fsw._emit(EV_CHANGE$2, file, newStats);\n        }\n        if (isLinux && prevStats.ino !== newStats.ino) {\n          this.fsw._closeFile(path);\n          prevStats = newStats;\n          this.fsw._addPathCloser(path, this._watchWithNodeFs(file, listener));\n        } else {\n          prevStats = newStats;\n        }\n      } catch (error) {\n        // Fix issues where mtime is null but file is still present\n        this.fsw._remove(dirname, basename);\n      }\n      // add is about to be emitted if file not already tracked in parent\n    } else if (parent.has(basename)) {\n      // Check that change event was not fired because of changed only accessTime.\n      const at = newStats.atimeMs;\n      const mt = newStats.mtimeMs;\n      if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n        this.fsw._emit(EV_CHANGE$2, file, newStats);\n      }\n      prevStats = newStats;\n    }\n  };\n  // kick off the watcher\n  const closer = this._watchWithNodeFs(file, listener);\n\n  // emit an add event if we're supposed to\n  if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {\n    if (!this.fsw._throttle(EV_ADD$2, file, 0)) return;\n    this.fsw._emit(EV_ADD$2, file, stats);\n  }\n\n  return closer;\n}\n\n/**\n * Handle symlinks encountered while reading a dir.\n * @param {Object} entry returned by readdirp\n * @param {String} directory path of dir being read\n * @param {String} path of this item\n * @param {String} item basename of this item\n * @returns {Promise<Boolean>} true if no more processing is needed for this entry.\n */\nasync _handleSymlink(entry, directory, path, item) {\n  if (this.fsw.closed) {\n    return;\n  }\n  const full = entry.fullPath;\n  const dir = this.fsw._getWatchedDir(directory);\n\n  if (!this.fsw.options.followSymlinks) {\n    // watch symlink directly (don't follow) and detect changes\n    this.fsw._incrReadyCount();\n\n    let linkPath;\n    try {\n      linkPath = await fsrealpath(path);\n    } catch (e) {\n      this.fsw._emitReady();\n      return true;\n    }\n\n    if (this.fsw.closed) return;\n    if (dir.has(item)) {\n      if (this.fsw._symlinkPaths.get(full) !== linkPath) {\n        this.fsw._symlinkPaths.set(full, linkPath);\n        this.fsw._emit(EV_CHANGE$2, path, entry.stats);\n      }\n    } else {\n      dir.add(item);\n      this.fsw._symlinkPaths.set(full, linkPath);\n      this.fsw._emit(EV_ADD$2, path, entry.stats);\n    }\n    this.fsw._emitReady();\n    return true;\n  }\n\n  // don't follow the same symlink more than once\n  if (this.fsw._symlinkPaths.has(full)) {\n    return true;\n  }\n\n  this.fsw._symlinkPaths.set(full, true);\n}\n\n_handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {\n  // Normalize the directory name on Windows\n  directory = sysPath$2.join(directory, EMPTY_STR$1);\n\n  if (!wh.hasGlob) {\n    throttler = this.fsw._throttle('readdir', directory, 1000);\n    if (!throttler) return;\n  }\n\n  const previous = this.fsw._getWatchedDir(wh.path);\n  const current = new Set();\n\n  let stream = this.fsw._readdirp(directory, {\n    fileFilter: entry => wh.filterPath(entry),\n    directoryFilter: entry => wh.filterDir(entry),\n    depth: 0\n  }).on(STR_DATA$1, async (entry) => {\n    if (this.fsw.closed) {\n      stream = undefined;\n      return;\n    }\n    const item = entry.path;\n    let path = sysPath$2.join(directory, item);\n    current.add(item);\n\n    if (entry.stats.isSymbolicLink() && await this._handleSymlink(entry, directory, path, item)) {\n      return;\n    }\n\n    if (this.fsw.closed) {\n      stream = undefined;\n      return;\n    }\n    // Files that present in current directory snapshot\n    // but absent in previous are added to watch list and\n    // emit `add` event.\n    if (item === target || !target && !previous.has(item)) {\n      this.fsw._incrReadyCount();\n\n      // ensure relativeness of path is preserved in case of watcher reuse\n      path = sysPath$2.join(dir, sysPath$2.relative(dir, path));\n\n      this._addToNodeFs(path, initialAdd, wh, depth + 1);\n    }\n  }).on(EV_ERROR$2, this._boundHandleError);\n\n  return new Promise(resolve =>\n    stream.once(STR_END$2, () => {\n      if (this.fsw.closed) {\n        stream = undefined;\n        return;\n      }\n      const wasThrottled = throttler ? throttler.clear() : false;\n\n      resolve();\n\n      // Files that absent in current directory snapshot\n      // but present in previous emit `remove` event\n      // and are removed from @watched[directory].\n      previous.getChildren().filter((item) => {\n        return item !== directory &&\n          !current.has(item) &&\n          // in case of intersecting globs;\n          // a path may have been filtered out of this readdir, but\n          // shouldn't be removed because it matches a different glob\n          (!wh.hasGlob || wh.filterPath({\n            fullPath: sysPath$2.resolve(directory, item)\n          }));\n      }).forEach((item) => {\n        this.fsw._remove(directory, item);\n      });\n\n      stream = undefined;\n\n      // one more time for any missed in case changes came in extremely quickly\n      if (wasThrottled) this._handleRead(directory, false, wh, target, dir, depth, throttler);\n    })\n  );\n}\n\n/**\n * Read directory to add / remove files from `@watched` list and re-read it on change.\n * @param {String} dir fs path\n * @param {fs.Stats} stats\n * @param {Boolean} initialAdd\n * @param {Number} depth relative to user-supplied path\n * @param {String} target child path targeted for watch\n * @param {Object} wh Common watch helpers for this path\n * @param {String} realpath\n * @returns {Promise<Function>} closer for the watcher instance.\n */\nasync _handleDir(dir, stats, initialAdd, depth, target, wh, realpath) {\n  const parentDir = this.fsw._getWatchedDir(sysPath$2.dirname(dir));\n  const tracked = parentDir.has(sysPath$2.basename(dir));\n  if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {\n    if (!wh.hasGlob || wh.globFilter(dir)) this.fsw._emit(EV_ADD_DIR$2, dir, stats);\n  }\n\n  // ensure dir is tracked (harmless if redundant)\n  parentDir.add(sysPath$2.basename(dir));\n  this.fsw._getWatchedDir(dir);\n  let throttler;\n  let closer;\n\n  const oDepth = this.fsw.options.depth;\n  if ((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath)) {\n    if (!target) {\n      await this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);\n      if (this.fsw.closed) return;\n    }\n\n    closer = this._watchWithNodeFs(dir, (dirPath, stats) => {\n      // if current directory is removed, do nothing\n      if (stats && stats.mtimeMs === 0) return;\n\n      this._handleRead(dirPath, false, wh, target, dir, depth, throttler);\n    });\n  }\n  return closer;\n}\n\n/**\n * Handle added file, directory, or glob pattern.\n * Delegates call to _handleFile / _handleDir after checks.\n * @param {String} path to file or ir\n * @param {Boolean} initialAdd was the file added at watch instantiation?\n * @param {Object} priorWh depth relative to user-supplied path\n * @param {Number} depth Child path actually targeted for watch\n * @param {String=} target Child path actually targeted for watch\n * @returns {Promise}\n */\nasync _addToNodeFs(path, initialAdd, priorWh, depth, target) {\n  const ready = this.fsw._emitReady;\n  if (this.fsw._isIgnored(path) || this.fsw.closed) {\n    ready();\n    return false;\n  }\n\n  const wh = this.fsw._getWatchHelpers(path, depth);\n  if (!wh.hasGlob && priorWh) {\n    wh.hasGlob = priorWh.hasGlob;\n    wh.globFilter = priorWh.globFilter;\n    wh.filterPath = entry => priorWh.filterPath(entry);\n    wh.filterDir = entry => priorWh.filterDir(entry);\n  }\n\n  // evaluate what is at the path we're being asked to watch\n  try {\n    const stats = await statMethods$1[wh.statMethod](wh.watchPath);\n    if (this.fsw.closed) return;\n    if (this.fsw._isIgnored(wh.watchPath, stats)) {\n      ready();\n      return false;\n    }\n\n    const follow = this.fsw.options.followSymlinks && !path.includes(STAR) && !path.includes(BRACE_START$1);\n    let closer;\n    if (stats.isDirectory()) {\n      const absPath = sysPath$2.resolve(path);\n      const targetPath = follow ? await fsrealpath(path) : path;\n      if (this.fsw.closed) return;\n      closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);\n      if (this.fsw.closed) return;\n      // preserve this symlink's target path\n      if (absPath !== targetPath && targetPath !== undefined) {\n        this.fsw._symlinkPaths.set(absPath, targetPath);\n      }\n    } else if (stats.isSymbolicLink()) {\n      const targetPath = follow ? await fsrealpath(path) : path;\n      if (this.fsw.closed) return;\n      const parent = sysPath$2.dirname(wh.watchPath);\n      this.fsw._getWatchedDir(parent).add(wh.watchPath);\n      this.fsw._emit(EV_ADD$2, wh.watchPath, stats);\n      closer = await this._handleDir(parent, stats, initialAdd, depth, path, wh, targetPath);\n      if (this.fsw.closed) return;\n\n      // preserve this symlink's target path\n      if (targetPath !== undefined) {\n        this.fsw._symlinkPaths.set(sysPath$2.resolve(path), targetPath);\n      }\n    } else {\n      closer = this._handleFile(wh.watchPath, stats, initialAdd);\n    }\n    ready();\n\n    this.fsw._addPathCloser(path, closer);\n    return false;\n\n  } catch (error) {\n    if (this.fsw._handleError(error)) {\n      ready();\n      return path;\n    }\n  }\n}\n\n};\n\nvar nodefsHandler = NodeFsHandler$1;\n\nvar fseventsHandlerExports = {};\nvar fseventsHandler = {\n  get exports(){ return fseventsHandlerExports; },\n  set exports(v){ fseventsHandlerExports = v; },\n};\n\nconst require$$3 = /*@__PURE__*/getAugmentedNamespace(fseventsImporter);\n\nconst fs$1 = require$$0$1;\nconst sysPath$1 = require$$0$2;\nconst { promisify: promisify$1 } = require$$2;\n\nlet fsevents;\ntry {\n  fsevents = require$$3.getFsEvents();\n} catch (error) {\n  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error);\n}\n\nif (fsevents) {\n  // TODO: real check\n  const mtch = process.version.match(/v(\\d+)\\.(\\d+)/);\n  if (mtch && mtch[1] && mtch[2]) {\n    const maj = Number.parseInt(mtch[1], 10);\n    const min = Number.parseInt(mtch[2], 10);\n    if (maj === 8 && min < 16) {\n      fsevents = undefined;\n    }\n  }\n}\n\nconst {\n  EV_ADD: EV_ADD$1,\n  EV_CHANGE: EV_CHANGE$1,\n  EV_ADD_DIR: EV_ADD_DIR$1,\n  EV_UNLINK: EV_UNLINK$1,\n  EV_ERROR: EV_ERROR$1,\n  STR_DATA,\n  STR_END: STR_END$1,\n  FSEVENT_CREATED,\n  FSEVENT_MODIFIED,\n  FSEVENT_DELETED,\n  FSEVENT_MOVED,\n  // FSEVENT_CLONED,\n  FSEVENT_UNKNOWN,\n  FSEVENT_TYPE_FILE,\n  FSEVENT_TYPE_DIRECTORY,\n  FSEVENT_TYPE_SYMLINK,\n\n  ROOT_GLOBSTAR,\n  DIR_SUFFIX,\n  DOT_SLASH,\n  FUNCTION_TYPE: FUNCTION_TYPE$1,\n  EMPTY_FN: EMPTY_FN$1,\n  IDENTITY_FN\n} = constants;\n\nconst Depth = (value) => isNaN(value) ? {} : {depth: value};\n\nconst stat$1 = promisify$1(fs$1.stat);\nconst lstat = promisify$1(fs$1.lstat);\nconst realpath = promisify$1(fs$1.realpath);\n\nconst statMethods = { stat: stat$1, lstat };\n\n/**\n * @typedef {String} Path\n */\n\n/**\n * @typedef {Object} FsEventsWatchContainer\n * @property {Set<Function>} listeners\n * @property {Function} rawEmitter\n * @property {{stop: Function}} watcher\n */\n\n// fsevents instance helper functions\n/**\n * Object to hold per-process fsevents instances (may be shared across chokidar FSWatcher instances)\n * @type {Map<Path,FsEventsWatchContainer>}\n */\nconst FSEventsWatchers = new Map();\n\n// Threshold of duplicate path prefixes at which to start\n// consolidating going forward\nconst consolidateThreshhold = 10;\n\nconst wrongEventFlags = new Set([\n  69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912\n]);\n\n/**\n * Instantiates the fsevents interface\n * @param {Path} path path to be watched\n * @param {Function} callback called when fsevents is bound and ready\n * @returns {{stop: Function}} new fsevents instance\n */\nconst createFSEventsInstance = (path, callback) => {\n  const stop = fsevents.watch(path, callback);\n  return {stop};\n};\n\n/**\n * Instantiates the fsevents interface or binds listeners to an existing one covering\n * the same file tree.\n * @param {Path} path           - to be watched\n * @param {Path} realPath       - real path for symlinks\n * @param {Function} listener   - called when fsevents emits events\n * @param {Function} rawEmitter - passes data to listeners of the 'raw' event\n * @returns {Function} closer\n */\nfunction setFSEventsListener(path, realPath, listener, rawEmitter) {\n  let watchPath = sysPath$1.extname(realPath) ? sysPath$1.dirname(realPath) : realPath;\n\n  const parentPath = sysPath$1.dirname(watchPath);\n  let cont = FSEventsWatchers.get(watchPath);\n\n  // If we've accumulated a substantial number of paths that\n  // could have been consolidated by watching one directory\n  // above the current one, create a watcher on the parent\n  // path instead, so that we do consolidate going forward.\n  if (couldConsolidate(parentPath)) {\n    watchPath = parentPath;\n  }\n\n  const resolvedPath = sysPath$1.resolve(path);\n  const hasSymlink = resolvedPath !== realPath;\n\n  const filteredListener = (fullPath, flags, info) => {\n    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);\n    if (\n      fullPath === resolvedPath ||\n      !fullPath.indexOf(resolvedPath + sysPath$1.sep)\n    ) listener(fullPath, flags, info);\n  };\n\n  // check if there is already a watcher on a parent path\n  // modifies `watchPath` to the parent path when it finds a match\n  let watchedParent = false;\n  for (const watchedPath of FSEventsWatchers.keys()) {\n    if (realPath.indexOf(sysPath$1.resolve(watchedPath) + sysPath$1.sep) === 0) {\n      watchPath = watchedPath;\n      cont = FSEventsWatchers.get(watchPath);\n      watchedParent = true;\n      break;\n    }\n  }\n\n  if (cont || watchedParent) {\n    cont.listeners.add(filteredListener);\n  } else {\n    cont = {\n      listeners: new Set([filteredListener]),\n      rawEmitter,\n      watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {\n        if (!cont.listeners.size) return;\n        const info = fsevents.getInfo(fullPath, flags);\n        cont.listeners.forEach(list => {\n          list(fullPath, flags, info);\n        });\n\n        cont.rawEmitter(info.event, fullPath, info);\n      })\n    };\n    FSEventsWatchers.set(watchPath, cont);\n  }\n\n  // removes this instance's listeners and closes the underlying fsevents\n  // instance if there are no more listeners left\n  return () => {\n    const lst = cont.listeners;\n\n    lst.delete(filteredListener);\n    if (!lst.size) {\n      FSEventsWatchers.delete(watchPath);\n      if (cont.watcher) return cont.watcher.stop().then(() => {\n        cont.rawEmitter = cont.watcher = undefined;\n        Object.freeze(cont);\n      });\n    }\n  };\n}\n\n// Decide whether or not we should start a new higher-level\n// parent watcher\nconst couldConsolidate = (path) => {\n  let count = 0;\n  for (const watchPath of FSEventsWatchers.keys()) {\n    if (watchPath.indexOf(path) === 0) {\n      count++;\n      if (count >= consolidateThreshhold) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\n// returns boolean indicating whether fsevents can be used\nconst canUse = () => fsevents && FSEventsWatchers.size < 128;\n\n// determines subdirectory traversal levels from root to path\nconst calcDepth = (path, root) => {\n  let i = 0;\n  while (!path.indexOf(root) && (path = sysPath$1.dirname(path)) !== root) i++;\n  return i;\n};\n\n// returns boolean indicating whether the fsevents' event info has the same type\n// as the one returned by fs.stat\nconst sameTypes = (info, stats) => (\n  info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() ||\n  info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() ||\n  info.type === FSEVENT_TYPE_FILE && stats.isFile()\n);\n\n/**\n * @mixin\n */\nlet FsEventsHandler$1 = class FsEventsHandler {\n\n/**\n * @param {import('../index').FSWatcher} fsw\n */\nconstructor(fsw) {\n  this.fsw = fsw;\n}\ncheckIgnored(path, stats) {\n  const ipaths = this.fsw._ignoredPaths;\n  if (this.fsw._isIgnored(path, stats)) {\n    ipaths.add(path);\n    if (stats && stats.isDirectory()) {\n      ipaths.add(path + ROOT_GLOBSTAR);\n    }\n    return true;\n  }\n\n  ipaths.delete(path);\n  ipaths.delete(path + ROOT_GLOBSTAR);\n}\n\naddOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n  const event = watchedDir.has(item) ? EV_CHANGE$1 : EV_ADD$1;\n  this.handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n}\n\nasync checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n  try {\n    const stats = await stat$1(path);\n    if (this.fsw.closed) return;\n    if (sameTypes(info, stats)) {\n      this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    } else {\n      this.handleEvent(EV_UNLINK$1, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    }\n  } catch (error) {\n    if (error.code === 'EACCES') {\n      this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    } else {\n      this.handleEvent(EV_UNLINK$1, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    }\n  }\n}\n\nhandleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n  if (this.fsw.closed || this.checkIgnored(path)) return;\n\n  if (event === EV_UNLINK$1) {\n    const isDirectory = info.type === FSEVENT_TYPE_DIRECTORY;\n    // suppress unlink events on never before seen files\n    if (isDirectory || watchedDir.has(item)) {\n      this.fsw._remove(parent, item, isDirectory);\n    }\n  } else {\n    if (event === EV_ADD$1) {\n      // track new directories\n      if (info.type === FSEVENT_TYPE_DIRECTORY) this.fsw._getWatchedDir(path);\n\n      if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {\n        // push symlinks back to the top of the stack to get handled\n        const curDepth = opts.depth === undefined ?\n          undefined : calcDepth(fullPath, realPath) + 1;\n        return this._addToFsEvents(path, false, true, curDepth);\n      }\n\n      // track new paths\n      // (other than symlinks being followed, which will be tracked soon)\n      this.fsw._getWatchedDir(parent).add(item);\n    }\n    /**\n     * @type {'add'|'addDir'|'unlink'|'unlinkDir'}\n     */\n    const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;\n    this.fsw._emit(eventName, path);\n    if (eventName === EV_ADD_DIR$1) this._addToFsEvents(path, false, true);\n  }\n}\n\n/**\n * Handle symlinks encountered during directory scan\n * @param {String} watchPath  - file/dir path to be watched with fsevents\n * @param {String} realPath   - real path (in case of symlinks)\n * @param {Function} transform  - path transformer\n * @param {Function} globFilter - path filter in case a glob pattern was provided\n * @returns {Function} closer for the watcher instance\n*/\n_watchWithFsEvents(watchPath, realPath, transform, globFilter) {\n  if (this.fsw.closed || this.fsw._isIgnored(watchPath)) return;\n  const opts = this.fsw.options;\n  const watchCallback = async (fullPath, flags, info) => {\n    if (this.fsw.closed) return;\n    if (\n      opts.depth !== undefined &&\n      calcDepth(fullPath, realPath) > opts.depth\n    ) return;\n    const path = transform(sysPath$1.join(\n      watchPath, sysPath$1.relative(watchPath, fullPath)\n    ));\n    if (globFilter && !globFilter(path)) return;\n    // ensure directories are tracked\n    const parent = sysPath$1.dirname(path);\n    const item = sysPath$1.basename(path);\n    const watchedDir = this.fsw._getWatchedDir(\n      info.type === FSEVENT_TYPE_DIRECTORY ? path : parent\n    );\n\n    // correct for wrong events emitted\n    if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {\n      if (typeof opts.ignored === FUNCTION_TYPE$1) {\n        let stats;\n        try {\n          stats = await stat$1(path);\n        } catch (error) {}\n        if (this.fsw.closed) return;\n        if (this.checkIgnored(path, stats)) return;\n        if (sameTypes(info, stats)) {\n          this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        } else {\n          this.handleEvent(EV_UNLINK$1, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        }\n      } else {\n        this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      }\n    } else {\n      switch (info.event) {\n      case FSEVENT_CREATED:\n      case FSEVENT_MODIFIED:\n        return this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      case FSEVENT_DELETED:\n      case FSEVENT_MOVED:\n        return this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      }\n    }\n  };\n\n  const closer = setFSEventsListener(\n    watchPath,\n    realPath,\n    watchCallback,\n    this.fsw._emitRaw\n  );\n\n  this.fsw._emitReady();\n  return closer;\n}\n\n/**\n * Handle symlinks encountered during directory scan\n * @param {String} linkPath path to symlink\n * @param {String} fullPath absolute path to the symlink\n * @param {Function} transform pre-existing path transformer\n * @param {Number} curDepth level of subdirectories traversed to where symlink is\n * @returns {Promise<void>}\n */\nasync _handleFsEventsSymlink(linkPath, fullPath, transform, curDepth) {\n  // don't follow the same symlink more than once\n  if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath)) return;\n\n  this.fsw._symlinkPaths.set(fullPath, true);\n  this.fsw._incrReadyCount();\n\n  try {\n    const linkTarget = await realpath(linkPath);\n    if (this.fsw.closed) return;\n    if (this.fsw._isIgnored(linkTarget)) {\n      return this.fsw._emitReady();\n    }\n\n    this.fsw._incrReadyCount();\n\n    // add the linkTarget for watching with a wrapper for transform\n    // that causes emitted paths to incorporate the link's path\n    this._addToFsEvents(linkTarget || linkPath, (path) => {\n      let aliasedPath = linkPath;\n      if (linkTarget && linkTarget !== DOT_SLASH) {\n        aliasedPath = path.replace(linkTarget, linkPath);\n      } else if (path !== DOT_SLASH) {\n        aliasedPath = sysPath$1.join(linkPath, path);\n      }\n      return transform(aliasedPath);\n    }, false, curDepth);\n  } catch(error) {\n    if (this.fsw._handleError(error)) {\n      return this.fsw._emitReady();\n    }\n  }\n}\n\n/**\n *\n * @param {Path} newPath\n * @param {fs.Stats} stats\n */\nemitAdd(newPath, stats, processPath, opts, forceAdd) {\n  const pp = processPath(newPath);\n  const isDir = stats.isDirectory();\n  const dirObj = this.fsw._getWatchedDir(sysPath$1.dirname(pp));\n  const base = sysPath$1.basename(pp);\n\n  // ensure empty dirs get tracked\n  if (isDir) this.fsw._getWatchedDir(pp);\n  if (dirObj.has(base)) return;\n  dirObj.add(base);\n\n  if (!opts.ignoreInitial || forceAdd === true) {\n    this.fsw._emit(isDir ? EV_ADD_DIR$1 : EV_ADD$1, pp, stats);\n  }\n}\n\ninitWatch(realPath, path, wh, processPath) {\n  if (this.fsw.closed) return;\n  const closer = this._watchWithFsEvents(\n    wh.watchPath,\n    sysPath$1.resolve(realPath || wh.watchPath),\n    processPath,\n    wh.globFilter\n  );\n  this.fsw._addPathCloser(path, closer);\n}\n\n/**\n * Handle added path with fsevents\n * @param {String} path file/dir path or glob pattern\n * @param {Function|Boolean=} transform converts working path to what the user expects\n * @param {Boolean=} forceAdd ensure add is emitted\n * @param {Number=} priorDepth Level of subdirectories already traversed.\n * @returns {Promise<void>}\n */\nasync _addToFsEvents(path, transform, forceAdd, priorDepth) {\n  if (this.fsw.closed) {\n    return;\n  }\n  const opts = this.fsw.options;\n  const processPath = typeof transform === FUNCTION_TYPE$1 ? transform : IDENTITY_FN;\n\n  const wh = this.fsw._getWatchHelpers(path);\n\n  // evaluate what is at the path we're being asked to watch\n  try {\n    const stats = await statMethods[wh.statMethod](wh.watchPath);\n    if (this.fsw.closed) return;\n    if (this.fsw._isIgnored(wh.watchPath, stats)) {\n      throw null;\n    }\n    if (stats.isDirectory()) {\n      // emit addDir unless this is a glob parent\n      if (!wh.globFilter) this.emitAdd(processPath(path), stats, processPath, opts, forceAdd);\n\n      // don't recurse further if it would exceed depth setting\n      if (priorDepth && priorDepth > opts.depth) return;\n\n      // scan the contents of the dir\n      this.fsw._readdirp(wh.watchPath, {\n        fileFilter: entry => wh.filterPath(entry),\n        directoryFilter: entry => wh.filterDir(entry),\n        ...Depth(opts.depth - (priorDepth || 0))\n      }).on(STR_DATA, (entry) => {\n        // need to check filterPath on dirs b/c filterDir is less restrictive\n        if (this.fsw.closed) {\n          return;\n        }\n        if (entry.stats.isDirectory() && !wh.filterPath(entry)) return;\n\n        const joinedPath = sysPath$1.join(wh.watchPath, entry.path);\n        const {fullPath} = entry;\n\n        if (wh.followSymlinks && entry.stats.isSymbolicLink()) {\n          // preserve the current depth here since it can't be derived from\n          // real paths past the symlink\n          const curDepth = opts.depth === undefined ?\n            undefined : calcDepth(joinedPath, sysPath$1.resolve(wh.watchPath)) + 1;\n\n          this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);\n        } else {\n          this.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);\n        }\n      }).on(EV_ERROR$1, EMPTY_FN$1).on(STR_END$1, () => {\n        this.fsw._emitReady();\n      });\n    } else {\n      this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);\n      this.fsw._emitReady();\n    }\n  } catch (error) {\n    if (!error || this.fsw._handleError(error)) {\n      // TODO: Strange thing: \"should not choke on an ignored watch path\" will be failed without 2 ready calls -__-\n      this.fsw._emitReady();\n      this.fsw._emitReady();\n    }\n  }\n\n  if (opts.persistent && forceAdd !== true) {\n    if (typeof transform === FUNCTION_TYPE$1) {\n      // realpath has already been resolved\n      this.initWatch(undefined, path, wh, processPath);\n    } else {\n      let realPath;\n      try {\n        realPath = await realpath(wh.watchPath);\n      } catch (e) {}\n      this.initWatch(realPath, path, wh, processPath);\n    }\n  }\n}\n\n};\n\nfseventsHandler.exports = FsEventsHandler$1;\nfseventsHandlerExports.canUse = canUse;\n\nconst { EventEmitter } = require$$0$3;\nconst fs = require$$0$1;\nconst sysPath = require$$0$2;\nconst { promisify } = require$$2;\nconst readdirp = readdirp_1;\nconst anymatch = anymatchExports.default;\nconst globParent = globParent$1;\nconst isGlob = isGlob$2;\nconst braces = braces_1;\nconst normalizePath = normalizePath$2;\n\nconst NodeFsHandler = nodefsHandler;\nconst FsEventsHandler = fseventsHandlerExports;\nconst {\n  EV_ALL,\n  EV_READY,\n  EV_ADD,\n  EV_CHANGE,\n  EV_UNLINK,\n  EV_ADD_DIR,\n  EV_UNLINK_DIR,\n  EV_RAW,\n  EV_ERROR,\n\n  STR_CLOSE,\n  STR_END,\n\n  BACK_SLASH_RE,\n  DOUBLE_SLASH_RE,\n  SLASH_OR_BACK_SLASH_RE,\n  DOT_RE,\n  REPLACER_RE,\n\n  SLASH,\n  SLASH_SLASH,\n  BRACE_START,\n  BANG,\n  ONE_DOT,\n  TWO_DOTS,\n  GLOBSTAR,\n  SLASH_GLOBSTAR,\n  ANYMATCH_OPTS,\n  STRING_TYPE,\n  FUNCTION_TYPE,\n  EMPTY_STR,\n  EMPTY_FN,\n\n  isWindows,\n  isMacos,\n  isIBMi\n} = constants;\n\nconst stat = promisify(fs.stat);\nconst readdir = promisify(fs.readdir);\n\n/**\n * @typedef {String} Path\n * @typedef {'all'|'add'|'addDir'|'change'|'unlink'|'unlinkDir'|'raw'|'error'|'ready'} EventName\n * @typedef {'readdir'|'watch'|'add'|'remove'|'change'} ThrottleType\n */\n\n/**\n *\n * @typedef {Object} WatchHelpers\n * @property {Boolean} followSymlinks\n * @property {'stat'|'lstat'} statMethod\n * @property {Path} path\n * @property {Path} watchPath\n * @property {Function} entryPath\n * @property {Boolean} hasGlob\n * @property {Object} globFilter\n * @property {Function} filterPath\n * @property {Function} filterDir\n */\n\nconst arrify = (value = []) => Array.isArray(value) ? value : [value];\nconst flatten = (list, result = []) => {\n  list.forEach(item => {\n    if (Array.isArray(item)) {\n      flatten(item, result);\n    } else {\n      result.push(item);\n    }\n  });\n  return result;\n};\n\nconst unifyPaths = (paths_) => {\n  /**\n   * @type {Array<String>}\n   */\n  const paths = flatten(arrify(paths_));\n  if (!paths.every(p => typeof p === STRING_TYPE)) {\n    throw new TypeError(`Non-string provided as watch path: ${paths}`);\n  }\n  return paths.map(normalizePathToUnix);\n};\n\n// If SLASH_SLASH occurs at the beginning of path, it is not replaced\n//     because \"//StoragePC/DrivePool/Movies\" is a valid network path\nconst toUnix = (string) => {\n  let str = string.replace(BACK_SLASH_RE, SLASH);\n  let prepend = false;\n  if (str.startsWith(SLASH_SLASH)) {\n    prepend = true;\n  }\n  while (str.match(DOUBLE_SLASH_RE)) {\n    str = str.replace(DOUBLE_SLASH_RE, SLASH);\n  }\n  if (prepend) {\n    str = SLASH + str;\n  }\n  return str;\n};\n\n// Our version of upath.normalize\n// TODO: this is not equal to path-normalize module - investigate why\nconst normalizePathToUnix = (path) => toUnix(sysPath.normalize(toUnix(path)));\n\nconst normalizeIgnored = (cwd = EMPTY_STR) => (path) => {\n  if (typeof path !== STRING_TYPE) return path;\n  return normalizePathToUnix(sysPath.isAbsolute(path) ? path : sysPath.join(cwd, path));\n};\n\nconst getAbsolutePath = (path, cwd) => {\n  if (sysPath.isAbsolute(path)) {\n    return path;\n  }\n  if (path.startsWith(BANG)) {\n    return BANG + sysPath.join(cwd, path.slice(1));\n  }\n  return sysPath.join(cwd, path);\n};\n\nconst undef = (opts, key) => opts[key] === undefined;\n\n/**\n * Directory entry.\n * @property {Path} path\n * @property {Set<Path>} items\n */\nclass DirEntry {\n  /**\n   * @param {Path} dir\n   * @param {Function} removeWatcher\n   */\n  constructor(dir, removeWatcher) {\n    this.path = dir;\n    this._removeWatcher = removeWatcher;\n    /** @type {Set<Path>} */\n    this.items = new Set();\n  }\n\n  add(item) {\n    const {items} = this;\n    if (!items) return;\n    if (item !== ONE_DOT && item !== TWO_DOTS) items.add(item);\n  }\n\n  async remove(item) {\n    const {items} = this;\n    if (!items) return;\n    items.delete(item);\n    if (items.size > 0) return;\n\n    const dir = this.path;\n    try {\n      await readdir(dir);\n    } catch (err) {\n      if (this._removeWatcher) {\n        this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));\n      }\n    }\n  }\n\n  has(item) {\n    const {items} = this;\n    if (!items) return;\n    return items.has(item);\n  }\n\n  /**\n   * @returns {Array<String>}\n   */\n  getChildren() {\n    const {items} = this;\n    if (!items) return;\n    return [...items.values()];\n  }\n\n  dispose() {\n    this.items.clear();\n    delete this.path;\n    delete this._removeWatcher;\n    delete this.items;\n    Object.freeze(this);\n  }\n}\n\nconst STAT_METHOD_F = 'stat';\nconst STAT_METHOD_L = 'lstat';\nclass WatchHelper {\n  constructor(path, watchPath, follow, fsw) {\n    this.fsw = fsw;\n    this.path = path = path.replace(REPLACER_RE, EMPTY_STR);\n    this.watchPath = watchPath;\n    this.fullWatchPath = sysPath.resolve(watchPath);\n    this.hasGlob = watchPath !== path;\n    /** @type {object|boolean} */\n    if (path === EMPTY_STR) this.hasGlob = false;\n    this.globSymlink = this.hasGlob && follow ? undefined : false;\n    this.globFilter = this.hasGlob ? anymatch(path, undefined, ANYMATCH_OPTS) : false;\n    this.dirParts = this.getDirParts(path);\n    this.dirParts.forEach((parts) => {\n      if (parts.length > 1) parts.pop();\n    });\n    this.followSymlinks = follow;\n    this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;\n  }\n\n  checkGlobSymlink(entry) {\n    // only need to resolve once\n    // first entry should always have entry.parentDir === EMPTY_STR\n    if (this.globSymlink === undefined) {\n      this.globSymlink = entry.fullParentDir === this.fullWatchPath ?\n        false : {realPath: entry.fullParentDir, linkPath: this.fullWatchPath};\n    }\n\n    if (this.globSymlink) {\n      return entry.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);\n    }\n\n    return entry.fullPath;\n  }\n\n  entryPath(entry) {\n    return sysPath.join(this.watchPath,\n      sysPath.relative(this.watchPath, this.checkGlobSymlink(entry))\n    );\n  }\n\n  filterPath(entry) {\n    const {stats} = entry;\n    if (stats && stats.isSymbolicLink()) return this.filterDir(entry);\n    const resolvedPath = this.entryPath(entry);\n    const matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE ?\n      this.globFilter(resolvedPath) : true;\n    return matchesGlob &&\n      this.fsw._isntIgnored(resolvedPath, stats) &&\n      this.fsw._hasReadPermissions(stats);\n  }\n\n  getDirParts(path) {\n    if (!this.hasGlob) return [];\n    const parts = [];\n    const expandedPath = path.includes(BRACE_START) ? braces.expand(path) : [path];\n    expandedPath.forEach((path) => {\n      parts.push(sysPath.relative(this.watchPath, path).split(SLASH_OR_BACK_SLASH_RE));\n    });\n    return parts;\n  }\n\n  filterDir(entry) {\n    if (this.hasGlob) {\n      const entryParts = this.getDirParts(this.checkGlobSymlink(entry));\n      let globstar = false;\n      this.unmatchedGlob = !this.dirParts.some((parts) => {\n        return parts.every((part, i) => {\n          if (part === GLOBSTAR) globstar = true;\n          return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i], ANYMATCH_OPTS);\n        });\n      });\n    }\n    return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry), entry.stats);\n  }\n}\n\n/**\n * Watches files & directories for changes. Emitted events:\n * `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`\n *\n *     new FSWatcher()\n *       .add(directories)\n *       .on('add', path => log('File', path, 'was added'))\n */\nclass FSWatcher extends EventEmitter {\n// Not indenting methods for history sake; for now.\nconstructor(_opts) {\n  super();\n\n  const opts = {};\n  if (_opts) Object.assign(opts, _opts); // for frozen objects\n\n  /** @type {Map<String, DirEntry>} */\n  this._watched = new Map();\n  /** @type {Map<String, Array>} */\n  this._closers = new Map();\n  /** @type {Set<String>} */\n  this._ignoredPaths = new Set();\n\n  /** @type {Map<ThrottleType, Map>} */\n  this._throttled = new Map();\n\n  /** @type {Map<Path, String|Boolean>} */\n  this._symlinkPaths = new Map();\n\n  this._streams = new Set();\n  this.closed = false;\n\n  // Set up default options.\n  if (undef(opts, 'persistent')) opts.persistent = true;\n  if (undef(opts, 'ignoreInitial')) opts.ignoreInitial = false;\n  if (undef(opts, 'ignorePermissionErrors')) opts.ignorePermissionErrors = false;\n  if (undef(opts, 'interval')) opts.interval = 100;\n  if (undef(opts, 'binaryInterval')) opts.binaryInterval = 300;\n  if (undef(opts, 'disableGlobbing')) opts.disableGlobbing = false;\n  opts.enableBinaryInterval = opts.binaryInterval !== opts.interval;\n\n  // Enable fsevents on OS X when polling isn't explicitly enabled.\n  if (undef(opts, 'useFsEvents')) opts.useFsEvents = !opts.usePolling;\n\n  // If we can't use fsevents, ensure the options reflect it's disabled.\n  const canUseFsEvents = FsEventsHandler.canUse();\n  if (!canUseFsEvents) opts.useFsEvents = false;\n\n  // Use polling on Mac if not using fsevents.\n  // Other platforms use non-polling fs_watch.\n  if (undef(opts, 'usePolling') && !opts.useFsEvents) {\n    opts.usePolling = isMacos;\n  }\n\n  // Always default to polling on IBM i because fs.watch() is not available on IBM i.\n  if(isIBMi) {\n    opts.usePolling = true;\n  }\n\n  // Global override (useful for end-developers that need to force polling for all\n  // instances of chokidar, regardless of usage/dependency depth)\n  const envPoll = process.env.CHOKIDAR_USEPOLLING;\n  if (envPoll !== undefined) {\n    const envLower = envPoll.toLowerCase();\n\n    if (envLower === 'false' || envLower === '0') {\n      opts.usePolling = false;\n    } else if (envLower === 'true' || envLower === '1') {\n      opts.usePolling = true;\n    } else {\n      opts.usePolling = !!envLower;\n    }\n  }\n  const envInterval = process.env.CHOKIDAR_INTERVAL;\n  if (envInterval) {\n    opts.interval = Number.parseInt(envInterval, 10);\n  }\n\n  // Editor atomic write normalization enabled by default with fs.watch\n  if (undef(opts, 'atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;\n  if (opts.atomic) this._pendingUnlinks = new Map();\n\n  if (undef(opts, 'followSymlinks')) opts.followSymlinks = true;\n\n  if (undef(opts, 'awaitWriteFinish')) opts.awaitWriteFinish = false;\n  if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};\n  const awf = opts.awaitWriteFinish;\n  if (awf) {\n    if (!awf.stabilityThreshold) awf.stabilityThreshold = 2000;\n    if (!awf.pollInterval) awf.pollInterval = 100;\n    this._pendingWrites = new Map();\n  }\n  if (opts.ignored) opts.ignored = arrify(opts.ignored);\n\n  let readyCalls = 0;\n  this._emitReady = () => {\n    readyCalls++;\n    if (readyCalls >= this._readyCount) {\n      this._emitReady = EMPTY_FN;\n      this._readyEmitted = true;\n      // use process.nextTick to allow time for listener to be bound\n      process.nextTick(() => this.emit(EV_READY));\n    }\n  };\n  this._emitRaw = (...args) => this.emit(EV_RAW, ...args);\n  this._readyEmitted = false;\n  this.options = opts;\n\n  // Initialize with proper watcher.\n  if (opts.useFsEvents) {\n    this._fsEventsHandler = new FsEventsHandler(this);\n  } else {\n    this._nodeFsHandler = new NodeFsHandler(this);\n  }\n\n  // You’re frozen when your heart’s not open.\n  Object.freeze(opts);\n}\n\n// Public methods\n\n/**\n * Adds paths to be watched on an existing FSWatcher instance\n * @param {Path|Array<Path>} paths_\n * @param {String=} _origAdd private; for handling non-existent paths to be watched\n * @param {Boolean=} _internal private; indicates a non-user add\n * @returns {FSWatcher} for chaining\n */\nadd(paths_, _origAdd, _internal) {\n  const {cwd, disableGlobbing} = this.options;\n  this.closed = false;\n  let paths = unifyPaths(paths_);\n  if (cwd) {\n    paths = paths.map((path) => {\n      const absPath = getAbsolutePath(path, cwd);\n\n      // Check `path` instead of `absPath` because the cwd portion can't be a glob\n      if (disableGlobbing || !isGlob(path)) {\n        return absPath;\n      }\n      return normalizePath(absPath);\n    });\n  }\n\n  // set aside negated glob strings\n  paths = paths.filter((path) => {\n    if (path.startsWith(BANG)) {\n      this._ignoredPaths.add(path.slice(1));\n      return false;\n    }\n\n    // if a path is being added that was previously ignored, stop ignoring it\n    this._ignoredPaths.delete(path);\n    this._ignoredPaths.delete(path + SLASH_GLOBSTAR);\n\n    // reset the cached userIgnored anymatch fn\n    // to make ignoredPaths changes effective\n    this._userIgnored = undefined;\n\n    return true;\n  });\n\n  if (this.options.useFsEvents && this._fsEventsHandler) {\n    if (!this._readyCount) this._readyCount = paths.length;\n    if (this.options.persistent) this._readyCount *= 2;\n    paths.forEach((path) => this._fsEventsHandler._addToFsEvents(path));\n  } else {\n    if (!this._readyCount) this._readyCount = 0;\n    this._readyCount += paths.length;\n    Promise.all(\n      paths.map(async path => {\n        const res = await this._nodeFsHandler._addToNodeFs(path, !_internal, 0, 0, _origAdd);\n        if (res) this._emitReady();\n        return res;\n      })\n    ).then(results => {\n      if (this.closed) return;\n      results.filter(item => item).forEach(item => {\n        this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));\n      });\n    });\n  }\n\n  return this;\n}\n\n/**\n * Close watchers or start ignoring events from specified paths.\n * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs\n * @returns {FSWatcher} for chaining\n*/\nunwatch(paths_) {\n  if (this.closed) return this;\n  const paths = unifyPaths(paths_);\n  const {cwd} = this.options;\n\n  paths.forEach((path) => {\n    // convert to absolute path unless relative path already matches\n    if (!sysPath.isAbsolute(path) && !this._closers.has(path)) {\n      if (cwd) path = sysPath.join(cwd, path);\n      path = sysPath.resolve(path);\n    }\n\n    this._closePath(path);\n\n    this._ignoredPaths.add(path);\n    if (this._watched.has(path)) {\n      this._ignoredPaths.add(path + SLASH_GLOBSTAR);\n    }\n\n    // reset the cached userIgnored anymatch fn\n    // to make ignoredPaths changes effective\n    this._userIgnored = undefined;\n  });\n\n  return this;\n}\n\n/**\n * Close watchers and remove all listeners from watched paths.\n * @returns {Promise<void>}.\n*/\nclose() {\n  if (this.closed) return this._closePromise;\n  this.closed = true;\n\n  // Memory management.\n  this.removeAllListeners();\n  const closers = [];\n  this._closers.forEach(closerList => closerList.forEach(closer => {\n    const promise = closer();\n    if (promise instanceof Promise) closers.push(promise);\n  }));\n  this._streams.forEach(stream => stream.destroy());\n  this._userIgnored = undefined;\n  this._readyCount = 0;\n  this._readyEmitted = false;\n  this._watched.forEach(dirent => dirent.dispose());\n  ['closers', 'watched', 'streams', 'symlinkPaths', 'throttled'].forEach(key => {\n    this[`_${key}`].clear();\n  });\n\n  this._closePromise = closers.length ? Promise.all(closers).then(() => undefined) : Promise.resolve();\n  return this._closePromise;\n}\n\n/**\n * Expose list of watched paths\n * @returns {Object} for chaining\n*/\ngetWatched() {\n  const watchList = {};\n  this._watched.forEach((entry, dir) => {\n    const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;\n    watchList[key || ONE_DOT] = entry.getChildren().sort();\n  });\n  return watchList;\n}\n\nemitWithAll(event, args) {\n  this.emit(...args);\n  if (event !== EV_ERROR) this.emit(EV_ALL, ...args);\n}\n\n// Common helpers\n// --------------\n\n/**\n * Normalize and emit events.\n * Calling _emit DOES NOT MEAN emit() would be called!\n * @param {EventName} event Type of event\n * @param {Path} path File or directory path\n * @param {*=} val1 arguments to be passed with event\n * @param {*=} val2\n * @param {*=} val3\n * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n */\nasync _emit(event, path, val1, val2, val3) {\n  if (this.closed) return;\n\n  const opts = this.options;\n  if (isWindows) path = sysPath.normalize(path);\n  if (opts.cwd) path = sysPath.relative(opts.cwd, path);\n  /** @type Array<any> */\n  const args = [event, path];\n  if (val3 !== undefined) args.push(val1, val2, val3);\n  else if (val2 !== undefined) args.push(val1, val2);\n  else if (val1 !== undefined) args.push(val1);\n\n  const awf = opts.awaitWriteFinish;\n  let pw;\n  if (awf && (pw = this._pendingWrites.get(path))) {\n    pw.lastChange = new Date();\n    return this;\n  }\n\n  if (opts.atomic) {\n    if (event === EV_UNLINK) {\n      this._pendingUnlinks.set(path, args);\n      setTimeout(() => {\n        this._pendingUnlinks.forEach((entry, path) => {\n          this.emit(...entry);\n          this.emit(EV_ALL, ...entry);\n          this._pendingUnlinks.delete(path);\n        });\n      }, typeof opts.atomic === 'number' ? opts.atomic : 100);\n      return this;\n    }\n    if (event === EV_ADD && this._pendingUnlinks.has(path)) {\n      event = args[0] = EV_CHANGE;\n      this._pendingUnlinks.delete(path);\n    }\n  }\n\n  if (awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted) {\n    const awfEmit = (err, stats) => {\n      if (err) {\n        event = args[0] = EV_ERROR;\n        args[1] = err;\n        this.emitWithAll(event, args);\n      } else if (stats) {\n        // if stats doesn't exist the file must have been deleted\n        if (args.length > 2) {\n          args[2] = stats;\n        } else {\n          args.push(stats);\n        }\n        this.emitWithAll(event, args);\n      }\n    };\n\n    this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);\n    return this;\n  }\n\n  if (event === EV_CHANGE) {\n    const isThrottled = !this._throttle(EV_CHANGE, path, 50);\n    if (isThrottled) return this;\n  }\n\n  if (opts.alwaysStat && val1 === undefined &&\n    (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE)\n  ) {\n    const fullPath = opts.cwd ? sysPath.join(opts.cwd, path) : path;\n    let stats;\n    try {\n      stats = await stat(fullPath);\n    } catch (err) {}\n    // Suppress event when fs_stat fails, to avoid sending undefined 'stat'\n    if (!stats || this.closed) return;\n    args.push(stats);\n  }\n  this.emitWithAll(event, args);\n\n  return this;\n}\n\n/**\n * Common handler for errors\n * @param {Error} error\n * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n */\n_handleError(error) {\n  const code = error && error.code;\n  if (error && code !== 'ENOENT' && code !== 'ENOTDIR' &&\n    (!this.options.ignorePermissionErrors || (code !== 'EPERM' && code !== 'EACCES'))\n  ) {\n    this.emit(EV_ERROR, error);\n  }\n  return error || this.closed;\n}\n\n/**\n * Helper utility for throttling\n * @param {ThrottleType} actionType type being throttled\n * @param {Path} path being acted upon\n * @param {Number} timeout duration of time to suppress duplicate actions\n * @returns {Object|false} tracking object or false if action should be suppressed\n */\n_throttle(actionType, path, timeout) {\n  if (!this._throttled.has(actionType)) {\n    this._throttled.set(actionType, new Map());\n  }\n\n  /** @type {Map<Path, Object>} */\n  const action = this._throttled.get(actionType);\n  /** @type {Object} */\n  const actionPath = action.get(path);\n\n  if (actionPath) {\n    actionPath.count++;\n    return false;\n  }\n\n  let timeoutObject;\n  const clear = () => {\n    const item = action.get(path);\n    const count = item ? item.count : 0;\n    action.delete(path);\n    clearTimeout(timeoutObject);\n    if (item) clearTimeout(item.timeoutObject);\n    return count;\n  };\n  timeoutObject = setTimeout(clear, timeout);\n  const thr = {timeoutObject, clear, count: 0};\n  action.set(path, thr);\n  return thr;\n}\n\n_incrReadyCount() {\n  return this._readyCount++;\n}\n\n/**\n * Awaits write operation to finish.\n * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.\n * @param {Path} path being acted upon\n * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished\n * @param {EventName} event\n * @param {Function} awfEmit Callback to be called when ready for event to be emitted.\n */\n_awaitWriteFinish(path, threshold, event, awfEmit) {\n  let timeoutHandler;\n\n  let fullPath = path;\n  if (this.options.cwd && !sysPath.isAbsolute(path)) {\n    fullPath = sysPath.join(this.options.cwd, path);\n  }\n\n  const now = new Date();\n\n  const awaitWriteFinish = (prevStat) => {\n    fs.stat(fullPath, (err, curStat) => {\n      if (err || !this._pendingWrites.has(path)) {\n        if (err && err.code !== 'ENOENT') awfEmit(err);\n        return;\n      }\n\n      const now = Number(new Date());\n\n      if (prevStat && curStat.size !== prevStat.size) {\n        this._pendingWrites.get(path).lastChange = now;\n      }\n      const pw = this._pendingWrites.get(path);\n      const df = now - pw.lastChange;\n\n      if (df >= threshold) {\n        this._pendingWrites.delete(path);\n        awfEmit(undefined, curStat);\n      } else {\n        timeoutHandler = setTimeout(\n          awaitWriteFinish,\n          this.options.awaitWriteFinish.pollInterval,\n          curStat\n        );\n      }\n    });\n  };\n\n  if (!this._pendingWrites.has(path)) {\n    this._pendingWrites.set(path, {\n      lastChange: now,\n      cancelWait: () => {\n        this._pendingWrites.delete(path);\n        clearTimeout(timeoutHandler);\n        return event;\n      }\n    });\n    timeoutHandler = setTimeout(\n      awaitWriteFinish,\n      this.options.awaitWriteFinish.pollInterval\n    );\n  }\n}\n\n_getGlobIgnored() {\n  return [...this._ignoredPaths.values()];\n}\n\n/**\n * Determines whether user has asked to ignore this path.\n * @param {Path} path filepath or dir\n * @param {fs.Stats=} stats result of fs.stat\n * @returns {Boolean}\n */\n_isIgnored(path, stats) {\n  if (this.options.atomic && DOT_RE.test(path)) return true;\n  if (!this._userIgnored) {\n    const {cwd} = this.options;\n    const ign = this.options.ignored;\n\n    const ignored = ign && ign.map(normalizeIgnored(cwd));\n    const paths = arrify(ignored)\n      .filter((path) => typeof path === STRING_TYPE && !isGlob(path))\n      .map((path) => path + SLASH_GLOBSTAR);\n    const list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);\n    this._userIgnored = anymatch(list, undefined, ANYMATCH_OPTS);\n  }\n\n  return this._userIgnored([path, stats]);\n}\n\n_isntIgnored(path, stat) {\n  return !this._isIgnored(path, stat);\n}\n\n/**\n * Provides a set of common helpers and properties relating to symlink and glob handling.\n * @param {Path} path file, directory, or glob pattern being watched\n * @param {Number=} depth at any depth > 0, this isn't a glob\n * @returns {WatchHelper} object containing helpers for this path\n */\n_getWatchHelpers(path, depth) {\n  const watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);\n  const follow = this.options.followSymlinks;\n\n  return new WatchHelper(path, watchPath, follow, this);\n}\n\n// Directory helpers\n// -----------------\n\n/**\n * Provides directory tracking objects\n * @param {String} directory path of the directory\n * @returns {DirEntry} the directory's tracking object\n */\n_getWatchedDir(directory) {\n  if (!this._boundRemove) this._boundRemove = this._remove.bind(this);\n  const dir = sysPath.resolve(directory);\n  if (!this._watched.has(dir)) this._watched.set(dir, new DirEntry(dir, this._boundRemove));\n  return this._watched.get(dir);\n}\n\n// File helpers\n// ------------\n\n/**\n * Check for read permissions.\n * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405\n * @param {fs.Stats} stats - object, result of fs_stat\n * @returns {Boolean} indicates whether the file can be read\n*/\n_hasReadPermissions(stats) {\n  if (this.options.ignorePermissionErrors) return true;\n\n  // stats.mode may be bigint\n  const md = stats && Number.parseInt(stats.mode, 10);\n  const st = md & 0o777;\n  const it = Number.parseInt(st.toString(8)[0], 10);\n  return Boolean(4 & it);\n}\n\n/**\n * Handles emitting unlink events for\n * files and directories, and via recursion, for\n * files and directories within directories that are unlinked\n * @param {String} directory within which the following item is located\n * @param {String} item      base path of item/directory\n * @returns {void}\n*/\n_remove(directory, item, isDirectory) {\n  // if what is being deleted is a directory, get that directory's paths\n  // for recursive deleting and cleaning of watched object\n  // if it is not a directory, nestedDirectoryChildren will be empty array\n  const path = sysPath.join(directory, item);\n  const fullPath = sysPath.resolve(path);\n  isDirectory = isDirectory != null\n    ? isDirectory\n    : this._watched.has(path) || this._watched.has(fullPath);\n\n  // prevent duplicate handling in case of arriving here nearly simultaneously\n  // via multiple paths (such as _handleFile and _handleDir)\n  if (!this._throttle('remove', path, 100)) return;\n\n  // if the only watched file is removed, watch for its return\n  if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) {\n    this.add(directory, item, true);\n  }\n\n  // This will create a new entry in the watched object in either case\n  // so we got to do the directory check beforehand\n  const wp = this._getWatchedDir(path);\n  const nestedDirectoryChildren = wp.getChildren();\n\n  // Recursively remove children directories / files.\n  nestedDirectoryChildren.forEach(nested => this._remove(path, nested));\n\n  // Check if item was on the watched list and remove it\n  const parent = this._getWatchedDir(directory);\n  const wasTracked = parent.has(item);\n  parent.remove(item);\n\n  // Fixes issue #1042 -> Relative paths were detected and added as symlinks\n  // (https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L612),\n  // but never removed from the map in case the path was deleted.\n  // This leads to an incorrect state if the path was recreated:\n  // https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L553\n  if (this._symlinkPaths.has(fullPath)) {\n    this._symlinkPaths.delete(fullPath);\n  }\n\n  // If we wait for this file to be fully written, cancel the wait.\n  let relPath = path;\n  if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path);\n  if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {\n    const event = this._pendingWrites.get(relPath).cancelWait();\n    if (event === EV_ADD) return;\n  }\n\n  // The Entry will either be a directory that just got removed\n  // or a bogus entry to a file, in either case we have to remove it\n  this._watched.delete(path);\n  this._watched.delete(fullPath);\n  const eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK;\n  if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path);\n\n  // Avoid conflicts if we later create another file with the same name\n  if (!this.options.useFsEvents) {\n    this._closePath(path);\n  }\n}\n\n/**\n * Closes all watchers for a path\n * @param {Path} path\n */\n_closePath(path) {\n  this._closeFile(path);\n  const dir = sysPath.dirname(path);\n  this._getWatchedDir(dir).remove(sysPath.basename(path));\n}\n\n/**\n * Closes only file-specific watchers\n * @param {Path} path\n */\n_closeFile(path) {\n  const closers = this._closers.get(path);\n  if (!closers) return;\n  closers.forEach(closer => closer());\n  this._closers.delete(path);\n}\n\n/**\n *\n * @param {Path} path\n * @param {Function} closer\n */\n_addPathCloser(path, closer) {\n  if (!closer) return;\n  let list = this._closers.get(path);\n  if (!list) {\n    list = [];\n    this._closers.set(path, list);\n  }\n  list.push(closer);\n}\n\n_readdirp(root, opts) {\n  if (this.closed) return;\n  const options = {type: EV_ALL, alwaysStat: true, lstat: true, ...opts};\n  let stream = readdirp(root, options);\n  this._streams.add(stream);\n  stream.once(STR_CLOSE, () => {\n    stream = undefined;\n  });\n  stream.once(STR_END, () => {\n    if (stream) {\n      this._streams.delete(stream);\n      stream = undefined;\n    }\n  });\n  return stream;\n}\n\n}\n\n// Export FSWatcher class\nchokidar.FSWatcher = FSWatcher;\n\n/**\n * Instantiates watcher with paths to be tracked.\n * @param {String|Array<String>} paths file/directory paths and/or globs\n * @param {Object=} options chokidar opts\n * @returns an instance of FSWatcher for chaining.\n */\nconst watch = (paths, options) => {\n  const watcher = new FSWatcher(options);\n  watcher.add(paths);\n  return watcher;\n};\n\nchokidar.watch = watch;\n\nclass FileWatcher {\n    constructor(task, chokidarOptions) {\n        this.transformWatchers = new Map();\n        this.chokidarOptions = chokidarOptions;\n        this.task = task;\n        this.watcher = this.createWatcher(null);\n    }\n    close() {\n        this.watcher.close();\n        for (const watcher of this.transformWatchers.values()) {\n            watcher.close();\n        }\n    }\n    unwatch(id) {\n        this.watcher.unwatch(id);\n        const transformWatcher = this.transformWatchers.get(id);\n        if (transformWatcher) {\n            this.transformWatchers.delete(id);\n            transformWatcher.close();\n        }\n    }\n    watch(id, isTransformDependency) {\n        if (isTransformDependency) {\n            const watcher = this.transformWatchers.get(id) ?? this.createWatcher(id);\n            watcher.add(id);\n            this.transformWatchers.set(id, watcher);\n        }\n        else {\n            this.watcher.add(id);\n        }\n    }\n    createWatcher(transformWatcherId) {\n        const task = this.task;\n        const isLinux = platform() === 'linux';\n        const isTransformDependency = transformWatcherId !== null;\n        const handleChange = (id, event) => {\n            const changedId = transformWatcherId || id;\n            if (isLinux) {\n                // unwatching and watching fixes an issue with chokidar where on certain systems,\n                // a file that was unlinked and immediately recreated would create a change event\n                // but then no longer any further events\n                watcher.unwatch(changedId);\n                watcher.add(changedId);\n            }\n            task.invalidate(changedId, { event, isTransformDependency });\n        };\n        const watcher = chokidar\n            .watch([], this.chokidarOptions)\n            .on('add', id => handleChange(id, 'create'))\n            .on('change', id => handleChange(id, 'update'))\n            .on('unlink', id => handleChange(id, 'delete'));\n        return watcher;\n    }\n}\n\nconst eventsRewrites = {\n    create: {\n        create: 'buggy',\n        delete: null,\n        update: 'create'\n    },\n    delete: {\n        create: 'update',\n        delete: 'buggy',\n        update: 'buggy'\n    },\n    update: {\n        create: 'buggy',\n        delete: 'delete',\n        update: 'update'\n    }\n};\nclass Watcher {\n    constructor(optionsList, emitter) {\n        this.buildDelay = 0;\n        this.buildTimeout = null;\n        this.closed = false;\n        this.invalidatedIds = new Map();\n        this.rerun = false;\n        this.running = true;\n        this.emitter = emitter;\n        emitter.close = this.close.bind(this);\n        this.tasks = optionsList.map(options => new Task(this, options));\n        for (const { watch } of optionsList) {\n            if (watch && typeof watch.buildDelay === 'number') {\n                this.buildDelay = Math.max(this.buildDelay, watch.buildDelay);\n            }\n        }\n        process$1.nextTick(() => this.run());\n    }\n    async close() {\n        if (this.closed)\n            return;\n        this.closed = true;\n        if (this.buildTimeout)\n            clearTimeout(this.buildTimeout);\n        for (const task of this.tasks) {\n            task.close();\n        }\n        await this.emitter.emit('close');\n        this.emitter.removeAllListeners();\n    }\n    invalidate(file) {\n        if (file) {\n            const previousEvent = this.invalidatedIds.get(file.id);\n            const event = previousEvent ? eventsRewrites[previousEvent][file.event] : file.event;\n            if (event === 'buggy') {\n                //TODO: throws or warn? Currently just ignore, uses new event\n                this.invalidatedIds.set(file.id, file.event);\n            }\n            else if (event === null) {\n                this.invalidatedIds.delete(file.id);\n            }\n            else {\n                this.invalidatedIds.set(file.id, event);\n            }\n        }\n        if (this.running) {\n            this.rerun = true;\n            return;\n        }\n        if (this.buildTimeout)\n            clearTimeout(this.buildTimeout);\n        this.buildTimeout = setTimeout(async () => {\n            this.buildTimeout = null;\n            try {\n                await Promise.all([...this.invalidatedIds].map(([id, event]) => this.emitter.emit('change', id, { event })));\n                this.invalidatedIds.clear();\n                await this.emitter.emit('restart');\n                this.emitter.removeListenersForCurrentRun();\n                this.run();\n            }\n            catch (error) {\n                this.invalidatedIds.clear();\n                await this.emitter.emit('event', {\n                    code: 'ERROR',\n                    error,\n                    result: null\n                });\n                await this.emitter.emit('event', {\n                    code: 'END'\n                });\n            }\n        }, this.buildDelay);\n    }\n    async run() {\n        this.running = true;\n        await this.emitter.emit('event', {\n            code: 'START'\n        });\n        for (const task of this.tasks) {\n            await task.run();\n        }\n        this.running = false;\n        await this.emitter.emit('event', {\n            code: 'END'\n        });\n        if (this.rerun) {\n            this.rerun = false;\n            this.invalidate();\n        }\n    }\n}\nclass Task {\n    constructor(watcher, options) {\n        this.cache = { modules: [] };\n        this.watchFiles = [];\n        this.closed = false;\n        this.invalidated = true;\n        this.watched = new Set();\n        this.watcher = watcher;\n        this.options = options;\n        this.skipWrite = Boolean(options.watch && options.watch.skipWrite);\n        this.outputs = this.options.output;\n        this.outputFiles = this.outputs.map(output => {\n            if (output.file || output.dir)\n                return resolve(output.file || output.dir);\n            return undefined;\n        });\n        const watchOptions = this.options.watch || {};\n        this.filter = createFilter(watchOptions.include, watchOptions.exclude);\n        this.fileWatcher = new FileWatcher(this, {\n            ...watchOptions.chokidar,\n            disableGlobbing: true,\n            ignoreInitial: true\n        });\n    }\n    close() {\n        this.closed = true;\n        this.fileWatcher.close();\n    }\n    invalidate(id, details) {\n        this.invalidated = true;\n        if (details.isTransformDependency) {\n            for (const module of this.cache.modules) {\n                if (!module.transformDependencies.includes(id))\n                    continue;\n                // effective invalidation\n                module.originalCode = null;\n            }\n        }\n        this.watcher.invalidate({ event: details.event, id });\n    }\n    async run() {\n        if (!this.invalidated)\n            return;\n        this.invalidated = false;\n        const options = {\n            ...this.options,\n            cache: this.cache\n        };\n        const start = Date.now();\n        await this.watcher.emitter.emit('event', {\n            code: 'BUNDLE_START',\n            input: this.options.input,\n            output: this.outputFiles\n        });\n        let result = null;\n        try {\n            result = await rollupInternal(options, this.watcher.emitter);\n            if (this.closed) {\n                return;\n            }\n            this.updateWatchedFiles(result);\n            this.skipWrite || (await Promise.all(this.outputs.map(output => result.write(output))));\n            await this.watcher.emitter.emit('event', {\n                code: 'BUNDLE_END',\n                duration: Date.now() - start,\n                input: this.options.input,\n                output: this.outputFiles,\n                result\n            });\n        }\n        catch (error) {\n            if (!this.closed) {\n                if (Array.isArray(error.watchFiles)) {\n                    for (const id of error.watchFiles) {\n                        this.watchFile(id);\n                    }\n                }\n                if (error.id) {\n                    this.cache.modules = this.cache.modules.filter(module => module.id !== error.id);\n                }\n            }\n            await this.watcher.emitter.emit('event', {\n                code: 'ERROR',\n                error,\n                result\n            });\n        }\n    }\n    updateWatchedFiles(result) {\n        const previouslyWatched = this.watched;\n        this.watched = new Set();\n        this.watchFiles = result.watchFiles;\n        this.cache = result.cache;\n        for (const id of this.watchFiles) {\n            this.watchFile(id);\n        }\n        for (const module of this.cache.modules) {\n            for (const depId of module.transformDependencies) {\n                this.watchFile(depId, true);\n            }\n        }\n        for (const id of previouslyWatched) {\n            if (!this.watched.has(id)) {\n                this.fileWatcher.unwatch(id);\n            }\n        }\n    }\n    watchFile(id, isTransformDependency = false) {\n        if (!this.filter(id))\n            return;\n        this.watched.add(id);\n        if (this.outputFiles.includes(id)) {\n            throw new Error('Cannot import the generated bundle');\n        }\n        // this is necessary to ensure that any 'renamed' files\n        // continue to be watched following an error\n        this.fileWatcher.watch(id, isTransformDependency);\n    }\n}\n\nexport { Task, Watcher };\n"],"mappings":"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AAK,EACL,UAAU,EACV,KAAK,EACL,KAAK,EACL,OAAO,EACP,KAAK,EACL,KAAK,EACL,KAAK,EACL,WAAW,EACX,WAAW,EACX,WAAW,EACX,KAAK,EACL,KAAK,EACL,KAAK,EACL,MAAM,EACN,KAAK,EACL,KAAK,EACL,KAAK,EACL,IAAI,EACJ,KAAK,EACL,MAAM,EACN,SAAS,EACT,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,IAAI,EACJ,IAAI,EACJ,KAAK,EACL,SAAS,EACT,IAAI,EACJ,MAAM,EACN,MAAM,EACN,MAAM,EACN,MAAM,EACN,MAAM,EACN,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,MAAM,EACN,KAAK,EACL,MAAM,EACN,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,IAAI,EACJ,KAAK,EACL,MAAM,EACN,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,MAAM,EACN,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,MAAM,EACN,KAAK,EACL,OAAO,EACP,KAAK,EACL,KAAK,EACL,MAAM,EACN,MAAM,EACN,KAAK,EACL,MAAM,EACN,KAAK,EACL,KAAK,EACL,KAAK,EACL,SAAS,EACT,OAAO,EACP,GAAG,EACH,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,OAAO,EACP,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,MAAM,EACN,MAAM,EACN,KAAK,EACL,MAAM,EACN,KAAK,EACL,KAAK,EACL,MAAM,EACN,MAAM,EACN,KAAK,EACL,MAAM,EACN,MAAM,EACN,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,I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"},"metadata":{},"sourceType":"module","externalDependencies":[]}